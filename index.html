<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
<meta property="og:type" content="website">
<meta property="og:title" content="英雄迟暮">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="英雄迟暮">
<meta property="og:description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Howie Lu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>英雄迟暮</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="英雄迟暮" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">英雄迟暮</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/pizzaup" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%85%AD%EF%BC%9A%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%20API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howie Lu">
      <meta itemprop="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="英雄迟暮">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%85%AD%EF%BC%9A%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%20API/" class="post-title-link" itemprop="url">Java8新特性之六：新的日期时间 API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-21 13:51:14 / 修改时间：14:14:03" itemprop="dateCreated datePublished" datetime="2021-01-21T13:51:14+08:00">2021-01-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java8新特性之三：stream-API"><a href="#Java8新特性之三：stream-API" class="headerlink" title="Java8新特性之三：stream API"></a>Java8新特性之三：stream API</h2><p>新的时间及日期API位于java.time中，下面是一些关键类</p>
<p>●Instant——它代表的是时间戳</p>
<p>●LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。</p>
<p>●LocalTime——它代表的是不含日期的时间</p>
<p>●LocalDateTime——它包含了日期及时间，不过还是没有偏移信息或者说时区。</p>
<p>●ZonedDateTime——这是一个包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的。</p>
<h3 id="ZoneId"><a href="#ZoneId" class="headerlink" title="ZoneId"></a>ZoneId</h3><p>Java 8中的时区操作被很大程度上简化了，新的时区类 <code>java.time.ZoneId</code> 是原有的 <code>java.util.TimeZone</code> 类的替代品。<br>ZoneId对象可以通过 <code>ZoneId.of()</code> 方法创建，也可以通过 <code>ZoneId.systemDefault()</code> 获取系统默认时区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId shanghaiZoneId = ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>);</span><br><span class="line">ZoneId systemZoneId = ZoneId.systemDefault();</span><br></pre></td></tr></table></figure>
<p><code>of()</code> 方法接收一个“区域/城市”的字符串作为参数，你可以通过 <code>getAvailableZoneIds()</code> 方法获取所有合法的“区域/城市”字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br></pre></td></tr></table></figure>
<p>对于老的时区类 <code>TimeZone</code>，Java 8也提供了转化方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();</span><br></pre></td></tr></table></figure>
<p>有了 <code>ZoneId</code>，我们就可以将一个 <code>LocalDate</code>、<code>LocalTime</code> 或 <code>LocalDateTime</code> 对象转化为 <code>ZonedDateTime</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);</span><br></pre></td></tr></table></figure>
<p><code>ZonedDateTime</code> 对象由两部分构成，<code>LocalDateTime</code> 和 <code>ZoneId</code>，其中 <code>2018-03-03T15:26:56.147</code> 部分为 <code>LocalDateTime</code>，<code>+08:00[Asia/Shanghai]</code> 部分为ZoneId。</p>
<p>另一种表示时区的方式是使用 <code>ZoneOffset</code>，它是以当前时间和 <strong>世界标准时间（UTC）/格林威治时间（GMT）</strong> 的偏差来计算，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset zoneOffset = ZoneOffset.of(<span class="string">&quot;+09:00&quot;</span>);</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);</span><br></pre></td></tr></table></figure>


<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>Instant类在Java日期与时间功能中，表示了时间线上一个确切的点，定义为距离初始时间的时间差（初始时间为GMT 1970年1月1日00:00）经测量一天有86400秒，从初始时间开始不断向前移动。</p>
<p><strong>创建一个Instant实例</strong></p>
<p>你可以通过Instant类的工厂方法创建一个Instant实例，例如你可以调用instant.now()来创建一个确切的表达当前时间的Instant对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br></pre></td></tr></table></figure>
<p>另外也有一些其它方法能创建Instant，具体请查阅Java官方文档。</p>
<p><strong>访问Instant的时间</strong></p>
<p>一个Instant对象里有两个域：距离初始时间的秒钟数、在当前一秒内的第几纳秒，他们的组合表达了当前时间点。你可以通过以下两个方法得到它们的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> seconds =  getEpochSecond()</span><br><span class="line"><span class="keyword">int</span> nanos   =   getNano()</span><br></pre></td></tr></table></figure>
<p><strong>Instant的计算</strong></p>
<p>Instant类有一些方法，可以用于获得另一Instant的值，例如：</p>
<ul>
<li><code>plusSeconds()</code></li>
<li><code>plusMillis()</code></li>
<li><code>plusNanos()</code></li>
<li><code>minusSeconds()</code></li>
<li><code>minusMillis()</code></li>
<li><code>minusNanos()</code></li>
</ul>
<p>我下面将向你展示两个例子，来说明这些方法如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Instant now     = Instant.now();</span><br><span class="line">Instant later   = now.plusSeconds(<span class="number">3</span>);</span><br><span class="line">Instant earlier = now.minusSeconds(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>第一行获得了一个Instant对象，表示当前时间。第二行创建了一个Instant表示三秒后，第三行创建了一个Instant表示三秒前。</p>
<blockquote>
<p>seconds 表示从 <code>1970-01-01 00:00:00</code> 开始到现在的秒数，nanos 表示纳秒部分（nanos的值不会超过999,999,999）</p>
</blockquote>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 <code>System.currentTimeMillis()</code> 来获取当前的微秒数。<br>某一个特定的时间点也可以使用Instant类来表示，Instant 类也可以用来创建老的 <code>java.util.Date</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();  </span><br><span class="line"><span class="keyword">long</span> millis = clock.millis();    </span><br><span class="line">Instant instant = clock.instant();  </span><br><span class="line">Date legacyDate = Date.from(instant);   <span class="comment">// legacy java.util.Date  </span></span><br></pre></td></tr></table></figure>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>LocalDate类是Java 8中日期时间功能里表示一个本地日期的类，它的日期是无时区属性的。<br>可以用来表示生日、节假日期等等。这个类用于表示一个确切的日期，而不是这个日期所在的时间（如java.util.Date中的2000.01.01表示的实际是这一天的00:00这个瞬间）。</p>
<p>LocalDate类位于java.time包下，人名叫java.time.LocalDate，创建出来的实例也是不可变对象，所以涉及它的计算方法将返回一个新的LocalDate。</p>
<p><strong>创建一个LocalDate实例</strong></p>
<p>我们有多种方式可以创建出 <code>LocalDate</code> 实例。第一种方法是使用 <code>now()</code> 方法获得值为今天当日的 <code>LocalDate</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br></pre></td></tr></table></figure>
<p>另一种方法是使用年月日信息构造出LocalDate对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate2 = LocalDate.of(<span class="number">2018</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>LocalDate 的 <code>of()</code> 方法创建出一个指定年月日的日期，并且没有时区信息。</p>
<p><strong>访问日期信息</strong></p>
<p>可以用如下方法访问LocalDate中的日期信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>   year       = localDate.getYear();</span><br><span class="line">Month month      = localDate.getMonth();</span><br><span class="line"><span class="keyword">int</span>   dayOfMonth = localDate.getDayOfMonth();</span><br><span class="line"><span class="keyword">int</span>   dayOfYear  = localDate.getDayOfYear();</span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek();</span><br></pre></td></tr></table></figure>
<p>可以注意到getMonth()与getDayOfWeek()方法返回了一个枚举类型代替一个int。你可以通过枚举类型中的getValue()来获得信息。</p>
<p><strong>LocalDate计算</strong></p>
<p>你可以进行一堆简单的日期计算，只要使用如下的方法：</p>
<ul>
<li><code>plusDays()</code></li>
<li><code>plusWeeks()</code></li>
<li><code>plusMonths()</code></li>
<li><code>plusYears()</code></li>
<li><code>minusDays()</code></li>
<li><code>minusWeeks()</code></li>
<li><code>minusMonths()</code></li>
<li><code>minusYears()</code></li>
</ul>
<p>以下举几个使用的例子来帮助理解使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate d  = LocalDate.of(<span class="number">2018</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">LocalDate d1 = localDate.plusYears(<span class="number">3</span>);</span><br><span class="line">LocalDate d2 = localDate.minusYears(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>第一行创建出一个新的LocalDate对象d，表示2018.3.5。</li>
<li>第二行创建了值等于d日期3年后的LocalDate对象，第三行也是一样，只是值改为d日期的三年前。 </li>
</ol>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>LocalTime类是Java 8中日期时间功能里表示一整天中某个时间点的类，它的时间是无时区属性的（早上10点等等）。比如你需要描述学校几点开学，这个时间不涉及在什么城市，这个描述是对任何国家城市都适用的，此时使用无时区的LocalTime就足够了。<br>LocalTime类的对象也是不可变的，所以计算方法会返回一个新的LocalTime实例。</p>
<p><strong>创建一个LocatTime实例</strong></p>
<p>有多种方式可以新建LocalTime实例。比如使用当前时间作为值新建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用指定的时分秒和纳秒来新建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime2 = LocalTime.of(<span class="number">21</span>, <span class="number">30</span>, <span class="number">59</span>, <span class="number">11001</span>);</span><br></pre></td></tr></table></figure>
<p>也有另一种版本的 <code>of()</code> 方法只需要小时分钟两项，或时分秒三项值作为参数。</p>
<p><strong>访问LocalTime对象的时间</strong></p>
<p>你可以通过这些方法访问其时、分、秒、纳秒：</p>
<ul>
<li><code>getHour()</code></li>
<li><code>getMinute()</code></li>
<li><code>getSecond()</code></li>
<li><code>getNano()</code></li>
</ul>
<p><strong>LocalTime的计算</strong></p>
<p>LocalTime类包含一系列方法，能帮你完成时间计算：</p>
<ul>
<li><code>plusHours()</code></li>
<li><code>plusMinutes()</code></li>
<li><code>plusSeconds()</code></li>
<li><code>plusNanos()</code></li>
<li><code>minusHours()</code></li>
<li><code>minusMinutes()</code></li>
<li><code>minusSeconds()</code></li>
<li><code>minusNanos()</code></li>
</ul>
<p>以下举一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime2 = LocalTime.of(<span class="number">21</span>, <span class="number">30</span>, <span class="number">59</span>, <span class="number">11001</span>);</span><br><span class="line">LocalTime localTimeLater   = localTime.plusHours(<span class="number">3</span>);</span><br><span class="line">LocalTime localTimeEarlier = localTime.minusHours(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>第一行新建一个LocalTime实例，表示21:30:50的第11001纳秒。</li>
<li>第二行新建了一个LocalTime实例表示这个时间的三小时后，第三行表示三小时前。</li>
<li>LocalTime类是Java 8中日期时间功能里表示一整天中某个时间点的类，它的时间是无时区属性的（早上10点等等）。比如你需要描述学校几点开学，这个时间不涉及在什么城市，这个描述是对任何国家城市都适用的，此时使用无时区的LocalTime就足够了。</li>
</ol>
<p>LocalTime类的对象也是不可变的，所以计算方法会返回一个新的LocalTime实例。</p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTime类是Java 8中日期时间功能里，用于表示当地的日期与时间的类，它的值是无时区属性的。你可以将其视为Java 8中LocalDate与LocalTime两个类的结合。</p>
<p>LocalDateTime类的值是不可变的，所以其计算方法会返回一个新的LocalDateTime实例。</p>
<p><strong>创建一个LocatDateTime实例</strong></p>
<p>可以通过LocalDateTime的静态工厂方法来创建LocalDateTime实例。以下举例使用 <code>now()</code> 方法创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用指定的年月日、时分秒、纳秒来新建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime2 = LocalDateTime.of(<span class="number">2018</span>, <span class="number">11</span>, <span class="number">26</span>, <span class="number">13</span>, <span class="number">55</span>, <span class="number">36</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p><strong>访问LocalDateTime对象的时间</strong></p>
<p>你可以通过这些方法访问其日期时间：</p>
<ul>
<li><code>getYear()</code></li>
<li><code>getMonth()</code></li>
<li><code>getDayOfMonth()</code></li>
<li><code>getDayOfWeek()</code></li>
<li><code>getDayOfYear()</code></li>
<li><code>getHour()</code></li>
<li><code>getMinute()</code></li>
<li><code>getSecond()</code></li>
<li><code>getNano()</code></li>
</ul>
<p>这些方法中有一些返回int有一些返回枚举类型，你可以通过枚举类型中的 <code>getValue()</code> 方法来获得int值。</p>
<p><strong>LocalDateTime的计算</strong></p>
<p>LocalDateTime 类包含一系列方法，能帮你完成时间计算：</p>
<ul>
<li><code>plusYears()</code></li>
<li><code>plusMonths()</code></li>
<li><code>plusDays()</code></li>
<li><code>plusHours()</code></li>
<li><code>plusMinutes()</code></li>
<li><code>plusSeconds()</code></li>
<li><code>plusNanos()</code></li>
<li><code>minusYears()</code></li>
<li><code>minusMonths()</code></li>
<li><code>minusDays()</code></li>
<li><code>minusHours()</code></li>
<li><code>minusMinutes()</code></li>
<li><code>minusSeconds()</code></li>
<li><code>minusNanos()</code></li>
</ul>
<p>以下举一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime  = LocalDateTime.now();</span><br><span class="line">LocalDateTime localDateTime1 = localDateTime.plusYears(<span class="number">3</span>);</span><br><span class="line">LocalDateTime localDateTime2 = localDateTime.minusYears(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>第一行新建一个LocalDateTime实例表示当前这个时间。</li>
<li>第二行新建了一个LocalDateTime实例表示三年后。</li>
<li>第三行也新建了一个LocalDateTime实例表示三小时前。</li>
</ol>
<h3 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h3><p>ZonedDateTime类是Java 8中日期时间功能里，用于表示带时区的日期与时间信息的类。可以用于表示一个真实事件的开始时间，如某火箭升空时间等等。</p>
<p>ZonedDateTime 类的值是不可变的，所以其计算方法会返回一个新的ZonedDateTime 实例。</p>
<p><strong>创建一个ZonedDateTime实例</strong></p>
<p>有多种方式可以新建ZonedDateTime实例。比如使用当前时间作为值新建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime dateTime = ZonedDateTime.now();</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用指定的年月日、时分秒、纳秒以及时区ID来新建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId zoneId = ZoneId.of(<span class="string">&quot;UTC+1&quot;</span>);</span><br><span class="line">ZonedDateTime dateTime2 = ZonedDateTime.of(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">30</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">1234</span>, zoneId);</span><br></pre></td></tr></table></figure>
<p><strong>访问ZonedDateTime对象的时间</strong></p>
<p>你可以通过这些方法访问其日期时间：</p>
<ul>
<li><code>getYear()</code></li>
<li><code>getMonth()</code></li>
<li><code>getDayOfMonth()</code></li>
<li><code>getDayOfWeek()</code></li>
<li><code>getDayOfYear()</code></li>
<li><code>getHour()</code></li>
<li><code>getMinute()</code></li>
<li><code>getSecond()</code></li>
<li><code>getNano()</code></li>
</ul>
<p>这些方法中有一些返回int有一些返回枚举类型，但可以通过枚举类型中的getValue()方法来获得int值。</p>
<p><strong>ZonedDateTime的计算</strong></p>
<p>ZonedDateTime类包含一系列方法，能帮你完成时间计算：</p>
<ul>
<li><code>plusYears()</code></li>
<li><code>plusMonths()</code></li>
<li><code>plusDays()</code></li>
<li><code>plusHours()</code></li>
<li><code>plusMinutes()</code></li>
<li><code>plusSeconds()</code></li>
<li><code>plusNanos()</code></li>
<li><code>minusYears()</code></li>
<li><code>minusMonths()</code></li>
<li><code>minusDays()</code></li>
<li><code>minusHours()</code></li>
<li><code>minusMinutes()</code></li>
<li><code>minusSeconds()</code></li>
<li><code>minusNanos()</code></li>
</ul>
<p>但注意计算时，若不巧跨越了夏令时（会补一小时或减一小时），可能得不到希望的结果。一个替代的正确做法是使用Period：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime zoneDateTime = previousDateTime.plus(Period.ofDays(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p><strong>时区</strong></p>
<p>时区是用ZoneId类表示的，你可以使用ZoneId.now()或ZoneId.of(“xxx”)来实例化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneId zoneId = ZoneId.of(<span class="string">&quot;UTC+1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>传给 <code>of()</code> 方法的参数是时区的ID，如“UTC+1”指距离UTC（格林威治时间）有一小时的时差，你可以使用你想要的时差来表示ZoneId（如+1与-5等等）<br>你也可以使用另一种方式表示zone id，即使用地区名字，也是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId zoneId2 = ZoneId.of(<span class="string">&quot;Europe/Copenhagen&quot;</span>);</span><br><span class="line">ZoneId zoneId3 = ZoneId.of(<span class="string">&quot;Europe/Paris&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h3><p>DateTimeFormatter类是Java 8中日期时间功能里，用于解析和格式化日期时间的类，位于 <code>java.time.format</code> 包下。</p>
<p><strong>预定义的DateTimeFormatter实例</strong></p>
<p>DateTimeFormatter类包含一系列预定义（常量）的实例，可以解析和格式化一些标准时间格式。这将让你免除麻烦的时间格式定义，类中包含如下预定义的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BASIC_ISO_DATE</span><br><span class="line"></span><br><span class="line">ISO_LOCAL_DATE</span><br><span class="line">ISO_LOCAL_TIME</span><br><span class="line">ISO_LOCAL_DATE_TIME</span><br><span class="line"></span><br><span class="line">ISO_OFFSET_DATE</span><br><span class="line">ISO_OFFSET_TIME</span><br><span class="line">ISO_OFFSET_DATE_TIME</span><br><span class="line"></span><br><span class="line">ISO_ZONED_DATE_TIME</span><br><span class="line"></span><br><span class="line">ISO_INSTANT</span><br><span class="line"></span><br><span class="line">ISO_DATE</span><br><span class="line">ISO_TIME</span><br><span class="line">ISO_DATE_TIME</span><br><span class="line"></span><br><span class="line">ISO_ORDINAL_TIME</span><br><span class="line">ISO_WEEK_DATE</span><br><span class="line"></span><br><span class="line">RFC_1123_DATE_TIME</span><br></pre></td></tr></table></figure>
<p>每个预定义的DateTimeFormatter实例都有不同的日期格式，我就不解释全部的了。具体的可以查阅Java官方文档，但我在这篇的后续中会解释其中几个，以方便理解。</p>
<p><strong>格式化日期</strong></p>
<p>当你获取一个DateTimeFormatter实例后，就可以用format()方便来将一个日期格式化为某种字符串，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE;</span><br><span class="line">String formattedDate = formatter.format(LocalDate.now());</span><br><span class="line">System.out.println(formattedDate);</span><br></pre></td></tr></table></figure>
<p>这个样例把LocalDate对象格式化了，并输出20150703，这个输出表示现在2018年，3月5日。<br>再举一个关于ZonedDateTime的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE;</span><br><span class="line">String formattedZonedDate = formatter.format(ZonedDateTime.now());</span><br><span class="line">System.out.println(<span class="string">&quot;formattedZonedDate = &quot;</span> + formattedZonedDate);</span><br></pre></td></tr></table></figure>
<p>这个例子会输出：20180305+0800<br>表示今年2018年，3月5日，位于UTC+8时区。</p>
<h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>一个Duration对象表示两个Instant间的一段时间，是在Java 8中加入的新功能。</p>
<p>一个Duration实例是不可变的，当创建出对象后就不能改变它的值了。你只能通过Duration的计算方法，来创建出一个新的Durtaion对象。你会在之后的教程中见到的。</p>
<p><strong>创建Duration实例</strong></p>
<p>使用 <code>Duration</code> 类的工厂方法来创建一个 <code>Duration</code> 对象，以下是一个使用 <code>between()</code> 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instant first = Instant.now();</span><br><span class="line"><span class="comment">// wait some time while something happens</span></span><br><span class="line">Instant second = Instant.now();</span><br><span class="line">Duration duration = Duration.between(first, second);</span><br></pre></td></tr></table></figure>
<p><strong>访问Duration的时间</strong></p>
<p>一个Duration对象里有两个域：纳秒值（小于一秒的部分），秒钟值（一共有几秒），他们的组合表达了时间长度。注意屯使用System.getCurrentTimeMillis()时不同，Duration不包含毫秒这个属性。<br>你可以通过以下两个方法得到它们的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> seconds =  getSeconds()</span><br><span class="line"><span class="keyword">int</span> nanos   =   getNano()</span><br></pre></td></tr></table></figure>
<p>你也可以转换整个时间到其它单位如纳秒、分钟、小时、天：</p>
<ul>
<li><code>toNanos()</code></li>
<li><code>toMillis()</code></li>
<li><code>toMinutes()</code></li>
<li><code>toHours()</code></li>
<li><code>toDays()</code></li>
</ul>
<p>举例而言：<code>toNanos()</code> 与 <code>getNano()</code> 不同，<code>toNanos()</code> 获得的是 <code>Duration</code> 整个时间共有多少纳秒，<br>而 <code>getNano()</code> 只是获得这段时间中小于一秒的部分。</p>
<p>你也许会问，为什么没有 <code>toSeconds()</code> 方法，因为已经有 <code>getSeconds()</code> 这个方法能达到同样的功能了。</p>
<p><strong>Duration计算</strong></p>
<p>Duration类包含一系列的计算方法：</p>
<ul>
<li><code>plusNanos()</code></li>
<li><code>plusMillis()</code></li>
<li><code>plusSeconds()</code></li>
<li><code>plusMinutes()</code></li>
<li><code>plusHours()</code></li>
<li><code>plusDays()</code></li>
<li><code>minusNanos()</code></li>
<li><code>minusMillis()</code></li>
<li><code>minusSeconds()</code></li>
<li><code>minusMinutes()</code></li>
<li><code>minusHours()</code></li>
<li><code>minusDays()</code></li>
</ul>
<p>这些方法所做的事都是相似的，我在这儿也不展示内部实现细节了，就展示一个加减的例子吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Duration start = ... <span class="comment">//obtain a start duration</span></span><br><span class="line">Duration added      = start.plusDays(<span class="number">3</span>);</span><br><span class="line">Duration subtracted = start.minusDays(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>第一行创建了一个Duration对象叫start，具体怎么创建可以参考前面的代码。</li>
<li>第二三行样例创建了两个新的Duration，通过调用start的加减操作，使得added对象表示的时间比start多三天，而substracted则少三天。</li>
</ol>
<p>所有的计算方法都会返回一个新的Duration，以保证Duration的不可变属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> days = duration.toDays();              <span class="comment">// 这段时间的总天数</span></span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();            <span class="comment">// 这段时间的小时数</span></span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();        <span class="comment">// 这段时间的分钟数</span></span><br><span class="line"><span class="keyword">long</span> seconds = duration.getSeconds();       <span class="comment">// 这段时间的秒数</span></span><br><span class="line"><span class="keyword">long</span> milliSeconds = duration.toMillis();    <span class="comment">// 这段时间的毫秒数</span></span><br><span class="line"><span class="keyword">long</span> nanoSeconds = duration.toNanos();      <span class="comment">// 这段时间的纳秒数</span></span><br></pre></td></tr></table></figure>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><h4 id="增加和减少日期"><a href="#增加和减少日期" class="headerlink" title="增加和减少日期"></a>增加和减少日期</h4><p>Java 8中的日期/时间类都是不可变的，这是为了保证线程安全。当然，新的日期/时间类也提供了方法用于创建对象的可变版本，比如增加一天或者减少一天：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>);          <span class="comment">// 2017-01-05</span></span><br><span class="line"></span><br><span class="line">LocalDate date1 = date.withYear(<span class="number">2016</span>);              <span class="comment">// 修改为 2016-01-05</span></span><br><span class="line">LocalDate date2 = date.withMonth(<span class="number">2</span>);                <span class="comment">// 修改为 2017-02-05</span></span><br><span class="line">LocalDate date3 = date.withDayOfMonth(<span class="number">1</span>);           <span class="comment">// 修改为 2017-01-01</span></span><br><span class="line"></span><br><span class="line">LocalDate date4 = date.plusYears(<span class="number">1</span>);                <span class="comment">// 增加一年 2018-01-05</span></span><br><span class="line">LocalDate date5 = date.minusMonths(<span class="number">2</span>);              <span class="comment">// 减少两个月 2016-11-05</span></span><br><span class="line">LocalDate date6 = date.plus(<span class="number">5</span>, ChronoUnit.DAYS);    <span class="comment">// 增加5天 2017-01-10</span></span><br></pre></td></tr></table></figure>
<p>上面例子中对于日期的操作比较简单，但是有些时候我们要面临更复杂的时间操作，比如将时间调到下一个工作日，<br>或者是下个月的最后一天，这时候我们可以使用 <code>with()</code> 方法的另一个重载方法，它接收一个TemporalAdjuster参数，<br>可以使我们更加灵活的调整日期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY));      <span class="comment">// 返回下一个距离当前时间最近的星期日</span></span><br><span class="line">LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY));   <span class="comment">// 返回本月最后一个星期六</span></span><br></pre></td></tr></table></figure>
<p>要使上面的代码正确编译，你需要使用静态导入 <code>TemporalAdjusters</code> 对象：</p>
<p><code>import static java.time.temporal.TemporalAdjusters.*;</code></p>
<p><code>TemporalAdjusters</code> 类中包含了很多静态方法可以直接使用，下面的表格列出了一些方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>dayOfWeekInMonth</code></td>
<td align="left">返回同一个月中每周的第几天</td>
</tr>
<tr>
<td align="center"><code>firstDayOfMonth</code></td>
<td align="left">返回当月的第一天</td>
</tr>
<tr>
<td align="center"><code>firstDayOfNextMonth</code></td>
<td align="left">返回下月的第一天</td>
</tr>
<tr>
<td align="center"><code>firstDayOfNextYear</code></td>
<td align="left">返回下一年的第一天</td>
</tr>
<tr>
<td align="center"><code>firstDayOfYear</code></td>
<td align="left">返回本年的第一天</td>
</tr>
<tr>
<td align="center"><code>firstInMonth</code></td>
<td align="left">返回同一个月中第一个星期几</td>
</tr>
<tr>
<td align="center"><code>lastDayOfMonth</code></td>
<td align="left">返回当月的最后一天</td>
</tr>
<tr>
<td align="center"><code>lastDayOfNextMonth</code></td>
<td align="left">返回下月的最后一天</td>
</tr>
<tr>
<td align="center"><code>lastDayOfNextYear</code></td>
<td align="left">返回下一年的最后一天</td>
</tr>
<tr>
<td align="center"><code>lastDayOfYear</code></td>
<td align="left">返回本年的最后一天</td>
</tr>
<tr>
<td align="center"><code>lastInMonth</code></td>
<td align="left">返回同一个月中最后一个星期几</td>
</tr>
<tr>
<td align="center"><code>next / previous</code></td>
<td align="left">返回后一个/前一个给定的星期几</td>
</tr>
<tr>
<td align="center"><code>nextOrSame / previousOrSame</code></td>
<td align="left">返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</td>
</tr>
</tbody></table>
<p>如果上面表格中列出的方法不能满足你的需求，你还可以创建自定义的 <code>TemporalAdjuster</code> 接口的实现，<br><code>TemporalAdjuster</code> 也是一个函数式接口，所以我们可以使用Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">date.with(temporal -&gt; &#123;</span><br><span class="line">    <span class="comment">// 当前日期</span></span><br><span class="line">    DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况下，每次增加一天</span></span><br><span class="line">    <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是星期五，增加三天</span></span><br><span class="line">    <span class="keyword">if</span> (dayOfWeek == DayOfWeek.FRIDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是星期六，增加两天</span></span><br><span class="line">    <span class="keyword">if</span> (dayOfWeek == DayOfWeek.SATURDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temporal.plus(dayToAdd, ChronoUnit.DAYS);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="其他历法"><a href="#其他历法" class="headerlink" title="其他历法"></a>其他历法</h3><p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。</p>
<p>此外Java 8还提供了4套其他历法（很奇怪为什么没有汉族人使用的农历），每套历法都包含一个日期类，分别是：</p>
<ul>
<li><code>ThaiBuddhistDate</code>：泰国佛教历</li>
<li><code>MinguoDate</code>：中华民国历</li>
<li><code>JapaneseDate</code>：日本历</li>
<li><code>HijrahDate</code>：伊斯兰历</li>
</ul>
<p>每个日期类都继承 <code>ChronoLocalDate</code> 类，所以可以在不知道具体历法的情况下也可以操作。不过这些历法一般不常用，除非是有某些特殊需求情况下才会使用。</p>
<p>这些不同的历法也可以用于向公历转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">JapaneseDate jpDate = JapaneseDate.from(date);</span><br></pre></td></tr></table></figure>
<p>由于它们都继承ChronoLocalDate类，所以在不知道具体历法情况下，可以通过ChronoLocalDate类操作日期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chronology jpChronology = Chronology.ofLocale(Locale.JAPANESE);</span><br><span class="line">ChronoLocalDate jpChronoLocalDate = jpChronology.dateNow();</span><br></pre></td></tr></table></figure>
<p>我们在开发过程中应该尽量避免使用 <code>ChronoLocalDate</code>，尽量用与历法无关的方式操作时间，因为不同的历法计算日期的方式不一样，<br>比如开发者会在程序中做一些假设，假设一年中有12个月，如果是中国农历中包含了闰月，一年有可能是13个月，<br>但开发者认为是12个月，多出来的一个月属于明年的。<br>再比如假设年份是累加的，过了一年就在原来的年份上加一，但日本天皇在换代之后需要重新纪年，所以过了一年年份可能会从1开始计算。</p>
<p>在实际开发过程中建议使用 <code>LocalDate</code>，包括存储、操作、业务规则的解读；除非需要将程序的输入或者输出本地化，<br>这时可以使用 <code>ChronoLocalDate</code> 类。</p>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zemliu/p/3290585.html">SimpleDateFormat的线程安全问题与解决方案</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/yiifaa/article/details/73499053">为什么SimpleDateFormat不是线程安全的？</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/liuwei0376/article/details/13620879">Java获取N天前，N天后的日期（如3天）</a></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://github.com/biezhi/learn-java8">biezhi</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E4%BA%94%EF%BC%9AOptional/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howie Lu">
      <meta itemprop="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="英雄迟暮">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E4%BA%94%EF%BC%9AOptional/" class="post-title-link" itemprop="url">Java8新特性之五：Optional</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-21 09:47:24 / 修改时间：09:58:24" itemprop="dateCreated datePublished" datetime="2021-01-21T09:47:24+08:00">2021-01-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java8新特性之五：Optional"><a href="#Java8新特性之五：Optional" class="headerlink" title="Java8新特性之五：Optional"></a>Java8新特性之五：Optional</h2><p>　　NullPointerException相信每个JAVA程序员都不陌生，是JAVA应用程序中最常见的异常。之前，Google Guava项目曾提出用Optional类来包装对象从而解决NullPointerException。受此影响，JDK8的类中也引入了Optional类，在新版的SpringData Jpa和Spring Redis Data中都已实现了对该方法的支持。</p>
<h3 id="1、Optional类"><a href="#1、Optional类" class="headerlink" title="1、Optional类"></a>1、Optional类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A container object which may or may not contain a non-null value.</span></span><br><span class="line"><span class="comment"> * If a value is present, &#123;<span class="doctag">@code</span> isPresent()&#125; will return &#123;<span class="doctag">@code</span> true&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> get()&#125; will return the value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common instance for &#123;<span class="doctag">@code</span> empty()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If non-null, the value; if null, indicates no value is present</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 其他省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　该方法的注释大致意思是：Optional是一个容器对象，它可能包含空值，也可能包含非空值。当属性value被设置时，isPesent()方法将返回true，并且get()方法将返回这个值。</p>
<p>　　该类支持泛型，即其属性value可以是任何对象的实例。</p>
<h3 id="2、Optional类的方法"><a href="#2、Optional类的方法" class="headerlink" title="2、Optional类的方法"></a>2、Optional类的方法</h3><table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法</strong></th>
<th><strong>方法说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>private Optional()</code></td>
<td>无参构造，构造一个空Optional</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><code>private Optional(T value)</code></td>
<td>根据传入的非空value构建Optional</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><code>public static&lt;T&gt; Optional&lt;T&gt; empty()</code></td>
<td>返回一个空的Optional，该实例的value为空</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><code>public static &lt;T&gt; Optional&lt;T&gt; of(T value)</code></td>
<td>根据传入的非空value构建Optional，与Optional(T value)方法作用相同</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><code>public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code></td>
<td>与of(T value)方法不同的是，ofNullable(T value)允许你传入一个空的value，当传入的是空值时其创建一个空Optional，当传入的value非空时，与of()作用相同</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><code>public T get()</code></td>
<td>返回Optional的值，如果容器为空，则抛出NoSuchElementException异常</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td><code>public boolean isPresent()</code></td>
<td>判断当家Optional是否已设置了值</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><code>public void ifPresent(Consumer&lt;? super T&gt; consumer)</code></td>
<td>判断当家Optional是否已设置了值，如果有值，则调用Consumer函数式接口进行处理</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><code>public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td>
<td>如果设置了值，且满足Predicate的判断条件，则返回该Optional，否则返回一个空的Optional</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td><code>public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</code></td>
<td>如果Optional设置了value，则调用Function对值进行处理，并返回包含处理后值的Optional，否则返回空Optional</td>
</tr>
<tr>
<td><strong>11</strong></td>
<td><code>public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</code></td>
<td>与map()方法类型，不同的是它的mapper结果已经是一个Optional，不需要再对结果进行包装</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td><code>public T orElse(T other)</code></td>
<td>如果Optional值不为空，则返回该值，否则返回other</td>
</tr>
<tr>
<td><strong>13</strong></td>
<td><code>public T orElseGet(Supplier&lt;? extends T&gt; other)</code></td>
<td>如果Optional值不为空，则返回该值，否则根据other另外生成一个</td>
</tr>
<tr>
<td><strong>14</strong></td>
<td><code>public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)throws X</code></td>
<td>如果Optional值不为空，则返回该值，否则通过supplier抛出一个异常</td>
</tr>
</tbody></table>
<h3 id="3、Optional类的方法举例"><a href="#3、Optional类的方法举例" class="headerlink" title="3、Optional类的方法举例"></a>3、Optional类的方法举例</h3><p>　　《Java 8 Features Tutorial – The ULTIMATE Guide》中给出了两个简单的例子，我们从这两个例子入手来简单了解一下Optional容器的使用。</p>
<p>　　<strong>示例一：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">　　Optional&lt; String &gt; fullName = Optional.ofNullable( <span class="keyword">null</span> );</span><br><span class="line">　　System.out.println( <span class="string">&quot;Full Name is set? &quot;</span> + fullName.isPresent() );</span><br><span class="line">　　System.out.println( <span class="string">&quot;Full Name: &quot;</span> + fullName.orElseGet( () -&gt; <span class="string">&quot;[none]&quot;</span> ) );</span><br><span class="line">　　System.out.println( fullName.map( s -&gt; <span class="string">&quot;Hey &quot;</span> + s + <span class="string">&quot;!&quot;</span> ).orElse( <span class="string">&quot;Hey Stranger!&quot;</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Full Name is set? false</span><br><span class="line">Full Name: [none]</span><br><span class="line">Hey Stranger!　　</span><br></pre></td></tr></table></figure>
<p>　　<strong>说明：</strong></p>
<p>　　ifPresent()方法当Optional实例的值非空时返回true，否则返回false; </p>
<p>　　orElseGet()方法当Optional包含非空值时返回该值，否则通过接收的function生成一个默认的；</p>
<p>　　map()方法转换当前Optional的值，并返回一个新的Optional实例；</p>
<p>　　orElse()方法与orElseGet方法相似，不同的是orElse()直接返回传入的默认值。</p>
<p>　　<strong>示例二：修改示例一，使其生成一个非空值的Optional实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt; String &gt; firstName = Optional.of( <span class="string">&quot;Tom&quot;</span> );</span><br><span class="line">System.out.println( <span class="string">&quot;First Name is set? &quot;</span> + firstName.isPresent() );</span><br><span class="line">System.out.println( <span class="string">&quot;First Name: &quot;</span> + firstName.orElseGet( () -&gt; <span class="string">&quot;[none]&quot;</span> ) );</span><br><span class="line">System.out.println( firstName.map( s -&gt; <span class="string">&quot;Hey &quot;</span> + s + <span class="string">&quot;!&quot;</span> ).orElse( <span class="string">&quot;Hey Stranger!&quot;</span> ) );</span><br></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First Name is set? true</span><br><span class="line">First Name: Tom</span><br><span class="line">Hey Tom!</span><br></pre></td></tr></table></figure>
<p>　　可以清晰地看出与示例一的区别。这不但简洁了我们的代码，而且使我们的代码更便于阅读。</p>
<p>　　下面看一下例子中使用到的几个方法的源码：</p>
<p>　　<strong>1）、of</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<strong>2）、isPresent</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<strong>3）、orElseGet</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<strong>4）、orElse</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　其他方法源码，读者可以去Optional源码中查看。</p>
<h3 id="4、使用Optional避免空指针"><a href="#4、使用Optional避免空指针" class="headerlink" title="4、使用Optional避免空指针"></a>4、使用Optional避免空指针</h3><p>　　在我们日常开发过程中不可避免地会遇到空指针问题，在以前，出现空指针问题，我们通常需要进行调试等方式才能最终定位到具体位置，尤其是在分布式系统服务之间的调用，问题更难定位。在使用Optional后，我们可以将接受到的参数对象进行包装，比如，订单服务要调用商品服务的一个接口，并将商品信息通过参数传入，这时候，传入的商品参数可能直接传入的就是null，这时，商品方法可以使用Optional.of(T)对传入的对象进行包装，如果T为空，则会直接抛出空指针异常，我们看到异常信息就能立即知道发生空指针的原因是参数T为空；或者，当传入的参数为空时，我们可以使用Optional.orElse()或Optional.orElseGet()方法生成一个默认的实例，再进行后续的操作。</p>
<p>　　下面再看个具体例子：在User类中有个Address类，在Address类中有个Street类,Street类中有streetName属性，现在的需求是：根据传入的User实例，获取对应的streetName，如果User为null或Address为null或Street为null，返回“nothing found”，否则返回对应的streetName。</p>
<p>　　<strong>实现一：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Address address;</span><br><span class="line">&#125;</span><br><span class="line">@Data</span><br><span class="line">public class Address &#123;</span><br><span class="line">   private Street street;</span><br><span class="line">&#125;</span><br><span class="line">@Data</span><br><span class="line">public class Street &#123;</span><br><span class="line">    private String streetName;</span><br><span class="line">    private Integer streetNo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> public String getUserSteetName(User user) &#123;</span><br><span class="line"></span><br><span class="line">    if(null !&#x3D; user) &#123;</span><br><span class="line"></span><br><span class="line">        Address address &#x3D; user.getAddress();</span><br><span class="line"></span><br><span class="line">        if(null !&#x3D; address) &#123;</span><br><span class="line"></span><br><span class="line">            Street street &#x3D; address.getStreet();</span><br><span class="line"></span><br><span class="line">            if(null !&#x3D; street) &#123;</span><br><span class="line">                return street.getStreetName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &quot;nothing found&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>　　<strong>实现二，使用Optional：</strong></p>
<p> 　在实现一中明显的问题是if判断层级太深，下面复用Optional改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Optional&lt;Address&gt; address &#x3D; Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line">@Data</span><br><span class="line">public class Address &#123;</span><br><span class="line">    private Optional&lt;Street&gt; street &#x3D; Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line">@Data</span><br><span class="line">public class Street &#123;</span><br><span class="line">    private String streetName;</span><br><span class="line">    private Integer streetNo;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserSteetName(User user) &#123;</span><br><span class="line"></span><br><span class="line">    Optional&lt;User&gt; userOptional &#x3D; Optional.ofNullable(user);</span><br><span class="line">    final String streetName &#x3D; userOptional.orElse(new User()).getAddress().orElse(new Address()).getStreet().orElse(new Street()).getStreetName();</span><br><span class="line">    return StringUtils.isEmpty(streetName) ? &quot;nothing found&quot; : streetName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　利用orElse()方法给定默认值的方式确保不会报空指针问题问题，同时也能实现需求。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuhenzhidu/">无恨之都</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%9B%9B%EF%BC%9A%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howie Lu">
      <meta itemprop="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="英雄迟暮">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%9B%9B%EF%BC%9A%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Java8新特性之四：接口默认方法和静态方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-21 09:23:09 / 修改时间：09:43:25" itemprop="dateCreated datePublished" datetime="2021-01-21T09:23:09+08:00">2021-01-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java8新特性之四：接口默认方法和静态方法"><a href="#Java8新特性之四：接口默认方法和静态方法" class="headerlink" title="Java8新特性之四：接口默认方法和静态方法"></a>Java8新特性之四：接口默认方法和静态方法</h2><p>​        JDK1.8开始，接口允许定义默认方法和静态方法。</p>
<p>　　接口默认方法的语法很简单，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default关键字 methodName(参数列表) &#123; &#x2F;&#x2F; 实现体 &#125;</span><br></pre></td></tr></table></figure>
<p>　　接口静态方法语法与类的静态方法类似，不同的是接口静态方法的修饰符只能是public。</p>
<h3 id="1、默认方法"><a href="#1、默认方法" class="headerlink" title="1、默认方法"></a>1、默认方法</h3><p>​        为了提高代码的可重用性。接口的默认方法有助于在扩展系统功能的同时，不对现有的继承关系及类库产生很大的影响。</p>
<p>​        例如在JDK1.8中，Java集合框架的Collection接口增加了stream()等默认方法，这些默认方法即增强了集合的功能，又能保证对低版本的JDK的兼容。</p>
<p>​        举个简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;birds can fly...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fishes can swim......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Bird bird = <span class="keyword">new</span> Bird();</span><br><span class="line">        bird.fly();</span><br><span class="line"></span><br><span class="line">        Fish fish = <span class="keyword">new</span> Fishe();</span><br><span class="line">        fish.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、静态方法"><a href="#2、静态方法" class="headerlink" title="2、静态方法"></a>2、静态方法</h3><p>　　假如有一个Animal工厂接口，该接口中有一个静态方法create()专门生产不同的Animal，在JDK1.8后由于引入了Lambda表达式，使子类不用覆写该接口的create()方法也可以生产任意的Animal，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">static</span> Animal <span class="title">create</span><span class="params">(Supplier&lt;Animal&gt; supplier)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> supplier.get();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnimalFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产一只鸟</span></span><br><span class="line">        Animal bird = AnimalFactory.create(Bird::<span class="keyword">new</span>);</span><br><span class="line">        bird.fly();</span><br><span class="line">　　　　　<span class="comment">// 生产一条鱼</span></span><br><span class="line">        Animal fish = AnimalFactory.create(Fishe::<span class="keyword">new</span>);</span><br><span class="line">        fish.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、接口静态方法的“类优先”原则"><a href="#3、接口静态方法的“类优先”原则" class="headerlink" title="3、接口静态方法的“类优先”原则"></a>3、接口静态方法的“类优先”原则</h3><p>　　如果一个接口实现类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略，如改写之前的Bird类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Bird类中的fly方法：birds can fly...&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird bird = <span class="keyword">new</span> Bird();</span><br><span class="line">        bird.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4、接口冲突"><a href="#4、接口冲突" class="headerlink" title="4、接口冲突"></a>4、接口冲突</h3><p>​        假如一个类实现了两个接口，两个接口中都有同样的默认方法，哪个是有效的？</p>
<p>　　答案是：两个都无效！</p>
<p>　　该类必须要覆该方法来解决冲突，否则编译器将会报错。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuhenzhidu/">无恨之都</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%89%EF%BC%9AStream%20API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howie Lu">
      <meta itemprop="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="英雄迟暮">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%89%EF%BC%9AStream%20API/" class="post-title-link" itemprop="url">Java8新特性之三：stream API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-20 10:24:13" itemprop="dateCreated datePublished" datetime="2021-01-20T10:24:13+08:00">2021-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-21 13:47:27" itemprop="dateModified" datetime="2021-01-21T13:47:27+08:00">2021-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java8新特性之三：stream-API"><a href="#Java8新特性之三：stream-API" class="headerlink" title="Java8新特性之三：stream API"></a>Java8新特性之三：stream API</h2><p>​        Java8的两个重大改变，一个是Lambda表达式，另一个就是本节要讲的Stream API表达式。Stream 是Java8中处理集合的关键抽象概念，它可以对集合进行非常复杂的查找、过滤、筛选等操作。</p>
<p>​        Stream API给我们操作集合带来了强大的功用，同时Stream API操作简单，容易上手。</p>
<h3 id="1、Stream的操作步骤"><a href="#1、Stream的操作步骤" class="headerlink" title="1、Stream的操作步骤"></a>1、Stream的操作步骤</h3><p>Stream有如下三个操作步骤：</p>
<p><strong>1.1 创建Stream</strong></p>
<p>从一个数据源，如集合、数组中获取流。</p>
<p><strong>1.2 中间操作</strong></p>
<p>一个操作的中间链，对数据源的数据进行操作。</p>
<p><strong>1.3 终止操作</strong></p>
<p>一个终止操作，执行中间操作链，并产生结果。</p>
<p>举个简单的例子：</p>
<p>假设有一个Person类和一个Person列表，现在有两个需求：1）找到年龄大于18岁的人并输出；2）找出所有中国人的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age, String country, <span class="keyword">char</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">personList.add(new Person(&quot;欧阳雪&quot;,18,&quot;中国&quot;,&#39;F&#39;));</span><br><span class="line">personList.add(new Person(&quot;Tom&quot;,24,&quot;美国&quot;,&#39;M&#39;));</span><br><span class="line">personList.add(new Person(&quot;Harley&quot;,22,&quot;英国&quot;,&#39;F&#39;));</span><br><span class="line">personList.add(new Person(&quot;向天笑&quot;,20,&quot;中国&quot;,&#39;M&#39;));</span><br><span class="line">personList.add(new Person(&quot;李康&quot;,22,&quot;中国&quot;,&#39;M&#39;));</span><br><span class="line">personList.add(new Person(&quot;小梅&quot;,20,&quot;中国&quot;,&#39;F&#39;));</span><br><span class="line">personList.add(new Person(&quot;何雪&quot;,21,&quot;中国&quot;,&#39;F&#39;));</span><br><span class="line">personList.add(new Person(&quot;李康&quot;,22,&quot;中国&quot;,&#39;M&#39;));</span><br></pre></td></tr></table></figure>
<p>在JDK8以前，我们可以通过遍历列表来完成。但是在有了Stream API后，可以这样来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1）找到年龄大于18岁的人并输出；</span></span><br><span class="line">    personList.stream().filter((p) -&gt; p.getAge() &gt; <span class="number">18</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2）找出所有中国人的数量</span></span><br><span class="line">    <span class="keyword">long</span> chinaPersonNum = personList.stream().filter((p) -&gt; p.getCountry().equals(<span class="string">&quot;中国&quot;</span>)).count();</span><br><span class="line">    System.out.println(<span class="string">&quot;中国人有：&quot;</span> + chinaPersonNum + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，personList.stream()是创建流，filter()属于中间操作，forEach、count()是终止操作。</p>
<h3 id="2、创建流"><a href="#2、创建流" class="headerlink" title="2、创建流"></a>2、创建流</h3><p>在使用流之前，首先需要拥有一个数据源，并通过StreamAPI提供的一些方法获取该数据源的流对象。数据源可以有多种形式：</p>
<p><strong>2.1 集合</strong></p>
<p>这种数据源较为常用，通过stream()方法即可获取流对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;(); </span><br><span class="line">Stream&lt;Person&gt; stream = list.stream();</span><br></pre></td></tr></table></figure>
<p><strong>2.2 数组</strong></p>
<p>通过Arrays类提供的静态函数stream()获取数组的流对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;chaimm&quot;</span>,<span class="string">&quot;peter&quot;</span>,<span class="string">&quot;john&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(names);</span><br></pre></td></tr></table></figure>
<p><strong>2.3 值</strong></p>
<p>直接将几个值变成流对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;chaimm&quot;</span>,<span class="string">&quot;peter&quot;</span>,<span class="string">&quot;john&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>2.4 文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream lines = Files.lines(Paths.get(“文件路径名”),Charset.defaultCharset()))&#123;</span><br><span class="line">    <span class="comment">//可对lines做一些操作</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.5 iterator</strong></p>
<p><strong>创建无限流</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">      .limit(<span class="number">10</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：Java7简化了IO操作，把打开IO操作放在try后的括号中即可省略关闭IO的代码。</p>
</blockquote>
<h3 id="3、中间操作和收集操作"><a href="#3、中间操作和收集操作" class="headerlink" title="3、中间操作和收集操作"></a>3、中间操作和收集操作</h3><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="left">类型</th>
<th align="left">返回类型</th>
<th align="left">使用的类型/函数式接口</th>
<th align="left">函数描述符</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>filter</code></td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left"><code>Predicate&lt;T&gt;</code></td>
<td align="left"><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td align="center"><code>distinct</code></td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>skip</code></td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left">long</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>map</code></td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;R&gt;</code></td>
<td align="left"><code>Function&lt;T, R&gt;</code></td>
<td align="left"><code>T -&gt; R</code></td>
</tr>
<tr>
<td align="center"><code>flatMap</code></td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;R&gt;</code></td>
<td align="left"><code>Function&lt;T, Stream&lt;R&gt;&gt;</code></td>
<td align="left"><code>T -&gt; Stream&lt;R&gt;</code></td>
</tr>
<tr>
<td align="center"><code>limit</code></td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left">long</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>sorted</code></td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left"><code>Comparator&lt;T&gt;</code></td>
<td align="left"><code>(T, T) -&gt; int</code></td>
</tr>
<tr>
<td align="center"><code>anyMatch</code></td>
<td align="left">终端</td>
<td align="left"><code>boolean</code></td>
<td align="left"><code>Predicate&lt;T&gt;</code></td>
<td align="left"><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td align="center"><code>noneMatch</code></td>
<td align="left">终端</td>
<td align="left"><code>boolean</code></td>
<td align="left"><code>Predicate&lt;T&gt;</code></td>
<td align="left"><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td align="center"><code>allMatch</code></td>
<td align="left">终端</td>
<td align="left"><code>boolean</code></td>
<td align="left"><code>Predicate&lt;T&gt;</code></td>
<td align="left"><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td align="center"><code>findAny</code></td>
<td align="left">终端</td>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>findFirst</code></td>
<td align="left">终端</td>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>forEach</code></td>
<td align="left">终端</td>
<td align="left"><code>void</code></td>
<td align="left"><code>Consumer&lt;T&gt;</code></td>
<td align="left"><code>T -&gt; void</code></td>
</tr>
<tr>
<td align="center"><code>collect</code></td>
<td align="left">终端</td>
<td align="left"><code>R</code></td>
<td align="left"><code>Collector&lt;T, A, R&gt;</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>reduce</code></td>
<td align="left">终端</td>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left"><code>BinaryOperator&lt;T&gt;</code></td>
<td align="left"><code>(T, T) -&gt; T</code></td>
</tr>
<tr>
<td align="center"><code>count</code></td>
<td align="left">终端</td>
<td align="left"><code>long</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="Stream中间操作–筛选与切片"><a href="#Stream中间操作–筛选与切片" class="headerlink" title="Stream中间操作–筛选与切片"></a>Stream中间操作–筛选与切片</h4><ul>
<li>filter：接收Lambda，从流中排除某些操作；</li>
<li>limit：截断流，使其元素不超过给定对象</li>
<li>skip(n)：跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流，与limit(n)互补</li>
<li>distinct：筛选，通过流所生成元素的hashCode()和equals()去除重复元素。</li>
</ul>
<p> <strong>limit举例</strong></p>
<p>需求，从Person列表中取出两个女性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personList.stream().filter((p) -&gt; p.getSex() &#x3D;&#x3D; &#39;F&#39;).limit(2).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p> <strong>skip举例</strong></p>
<p>从Person列表中从第2个女性开始，取出所有的女性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personList.stream().filter((p) -&gt; p.getSex() &#x3D;&#x3D; &#39;F&#39;).skip(1).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p> <strong>distinct举例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personList.stream().filter((p) -&gt; p.getSex() &#x3D;&#x3D; &#39;M&#39;).distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="Stream中间操作–映射"><a href="#Stream中间操作–映射" class="headerlink" title="Stream中间操作–映射"></a>Stream中间操作–映射</h4><ul>
<li>map–接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li>
<li>flatMap–接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</li>
</ul>
<p><strong>map举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;Java 8&quot;</span>, <span class="string">&quot;Lambdas&quot;</span>, <span class="string">&quot;In&quot;</span>, <span class="string">&quot;Action&quot;</span>);</span><br><span class="line"></span><br><span class="line">    words.stream()</span><br><span class="line">        .map(word -&gt; word.length())</span><br><span class="line">        .collect(Collectors.toList())</span><br><span class="line">        .forEach(i -&gt; System.out.println(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>flatMap举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;I am a boy&quot;</span>, <span class="string">&quot;I love the girl&quot;</span>, <span class="string">&quot;But the girl loves another girl&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list.stream()</span><br><span class="line">        .map(word -&gt; word.split(<span class="string">&quot; &quot;</span>))   <span class="comment">// Stream&lt;String&gt;</span></span><br><span class="line">        .flatMap(Arrays::stream)</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stream中间操作–排序"><a href="#Stream中间操作–排序" class="headerlink" title="Stream中间操作–排序"></a>Stream中间操作–排序</h4><ul>
<li>sorted()–自然排序(Comparable)</li>
<li>sorted(Comparator com)–定制排序（Comparator）</li>
</ul>
<p>自然排序比较好理解，这里只讲一下定制排序，对前面的personList按年龄从小到大排序,年龄相同，则再按姓名排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Stream&lt;Person&gt; sorted = personList.stream().sorted((p1, p2) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1.getAge().equals(p2.getAge())) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getName().compareTo(p2.getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getAge().compareTo(p2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">sorted.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="Stream终止操作–查找与匹配"><a href="#Stream终止操作–查找与匹配" class="headerlink" title="Stream终止操作–查找与匹配"></a>Stream终止操作–查找与匹配</h4><ul>
<li>allMatch–检查是否匹配所有元素</li>
<li>anyMatch–检查是否至少匹配一个元素</li>
<li>noneMatch–检查是否没有匹配所有元素</li>
<li>findFirst–返回第一个元素</li>
<li>findAny–返回当前流中的任意元素</li>
<li>count–返回流中元素的总个数</li>
<li>max–返回流中最大值</li>
<li>min–返回流中最小值</li>
</ul>
<p>这些方面在Stream类中都有说明，这里不一一举例，只对allMatch、max各举一例进行说明。</p>
<p><strong>allMatch</strong></p>
<p>判断personList中的人是否都是成年人：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> adult = personList.stream().allMatch(p -&gt; p.getAge() &gt;= <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;是否都是成年人：&quot;</span> + adult);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> chinaese = personList.stream().allMatch(p -&gt; p.getCountry().equals(<span class="string">&quot;中国&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;是否都是中国人：&quot;</span> + chinaese);</span><br></pre></td></tr></table></figure>


<p><strong>max min</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Optional&lt;Person&gt; maxAge = personList.stream().max((p1, p2) -&gt; p1.getAge().compareTo(p2.getAge()));</span><br><span class="line">System.out.println(<span class="string">&quot;年龄最大的人信息：&quot;</span> + maxAge.get());</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Optional&lt;Person&gt; minAge = personList.stream().min((p1, p2) -&gt; p1.getAge().compareTo(p2.getAge()));</span><br><span class="line">System.out.println(<span class="string">&quot;年龄最小的人信息：&quot;</span> + minAge.get());</span><br></pre></td></tr></table></figure>
<h4 id="Stream终止操作–归约"><a href="#Stream终止操作–归约" class="headerlink" title="Stream终止操作–归约"></a>Stream终止操作–归约</h4><p>归约是将集合中的所有元素经过指定运算，折叠成一个元素输出，如：求最值、平均数等，这些操作都是将一个集合的元素折叠成一个元素输出。</p>
<p>例：计算所有人的年龄总和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = list.stream().reduce(<span class="number">0</span>, (person1,person2)-&gt;person1.getAge()+person2.getAge());</span><br></pre></td></tr></table></figure>
<ol>
<li>reduce的第一个参数表示初试值为0；</li>
<li>reduce的第二个参数为需要进行的归约操作，它接收一个拥有两个参数的Lambda表达式，reduce会把流中的元素两两输给Lambda表达式，最后将计算出累加之和。</li>
</ol>
<h3 id="4、Collector-收集"><a href="#4、Collector-收集" class="headerlink" title="4、Collector 收集"></a>4、Collector 收集</h3><table>
<thead>
<tr>
<th align="center">工厂方法</th>
<th align="left">返回类型</th>
<th align="left">用途</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>toList</code></td>
<td align="left"><code>List&lt;T&gt;</code></td>
<td align="left">把流中所有项目收集到一个 List</td>
<td align="left"><code>List&lt;Project&gt; projects = projectStream.collect(toList());</code></td>
</tr>
<tr>
<td align="center"><code>toSet</code></td>
<td align="left"><code>Set&lt;T&gt;</code></td>
<td align="left">把流中所有项目收集到一个 Set，删除重复项</td>
<td align="left"><code>Set&lt;Project&gt; projects = projectStream.collect(toSet());</code></td>
</tr>
<tr>
<td align="center"><code>toCollection</code></td>
<td align="left"><code>Collection&lt;T&gt;</code></td>
<td align="left">把流中所有项目收集到给定的供应源创建的集合</td>
<td align="left"><code>Collection&lt;Project&gt; projects = projectStream.collect(toCollection(), ArrayList::new);</code></td>
</tr>
<tr>
<td align="center"><code>counting</code></td>
<td align="left"><code>Long</code></td>
<td align="left">计算流中元素的个数</td>
<td align="left"><code>long howManyProjects = projectStream.collect(counting());</code></td>
</tr>
<tr>
<td align="center"><code>summingInt</code></td>
<td align="left"><code>Integer</code></td>
<td align="left">对流中项目的一个整数属性求和</td>
<td align="left"><code>int totalStars = projectStream.collect(summingInt(Project::getStars));</code></td>
</tr>
<tr>
<td align="center"><code>averagingInt</code></td>
<td align="left"><code>Double</code></td>
<td align="left">计算流中项目 Integer 属性的平均值</td>
<td align="left"><code>double avgStars = projectStream.collect(averagingInt(Project::getStars));</code></td>
</tr>
<tr>
<td align="center"><code>summarizingInt</code></td>
<td align="left"><code>IntSummaryStatistics</code></td>
<td align="left">收集关于流中项目 Integer 属性的统计值，例如最大、最小、 总和与平均值</td>
<td align="left"><code>IntSummaryStatistics projectStatistics = projectStream.collect(summarizingInt(Project::getStars));</code></td>
</tr>
<tr>
<td align="center"><code>joining</code></td>
<td align="left"><code>String</code></td>
<td align="left">连接对流中每个项目调用 toString 方法所生成的字符串</td>
<td align="left"><code>String shortProject = projectStream.map(Project::getName).collect(joining(&quot;, &quot;));</code></td>
</tr>
<tr>
<td align="center"><code>maxBy</code></td>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left">按照给定比较器选出的最大元素的 Optional， 或如果流为空则为 Optional.empty()</td>
<td align="left"><code>Optional&lt;Project&gt; fattest = projectStream.collect(maxBy(comparingInt(Project::getStars)));</code></td>
</tr>
<tr>
<td align="center"><code>minBy</code></td>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left">按照给定比较器选出的最小元素的 Optional， 或如果流为空则为 Optional.empty()</td>
<td align="left"><code>Optional&lt;Project&gt; fattest = projectStream.collect(minBy(comparingInt(Project::getStars)));</code></td>
</tr>
<tr>
<td align="center"><code>reducing</code></td>
<td align="left">归约操作产生的类型</td>
<td align="left">从一个作为累加器的初始值开始，利用 BinaryOperator 与流中的元素逐个结合，从而将流归约为单个值</td>
<td align="left"><code>int totalStars = projectStream.collect(reducing(0, Project::getStars, Integer::sum));</code></td>
</tr>
<tr>
<td align="center"><code>collectingAndThen</code></td>
<td align="left">转换函数返回的类型</td>
<td align="left">包含另一个收集器，对其结果应用转换函数</td>
<td align="left"><code>int howManyProjects = projectStream.collect(collectingAndThen(toList(), List::size));</code></td>
</tr>
<tr>
<td align="center"><code>groupingBy</code></td>
<td align="left"><code>Map&lt;K, List&lt;T&gt;&gt;</code></td>
<td align="left">根据项目的一个属性的值对流中的项目作问组，并将属性值作 为结果 Map 的键</td>
<td align="left"><code>Map&lt;String,List&lt;Project&gt;&gt; projectByLanguage = projectStream.collect(groupingBy(Project::getLanguage));</code></td>
</tr>
<tr>
<td align="center"><code>partitioningBy</code></td>
<td align="left"><code>Map&lt;Boolean,List&lt;T&gt;&gt;</code></td>
<td align="left">根据对流中每个项目应用断言的结果来对项目进行分区</td>
<td align="left"><code>Map&lt;Boolean,List&lt;Project&gt;&gt; vegetarianDishes = projectStream.collect(partitioningBy(Project::isVegetarian));</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​        收集器用来将经过筛选、映射的流进行最后的整理，可以使得最后的结果以不同的形式展现。<br><code>collect</code> 方法即为收集器，它接收 <code>Collector</code> 接口的实现作为具体收集器的收集方法。<br><code>Collector</code> 接口提供了很多默认实现的方法，我们可以直接使用它们格式化流的结果；也可以自定义 <code>Collector</code> 接口的实现，从而定制自己的收集器。</p>
<h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><p>流由一个个元素组成，归约就是将一个个元素“折叠”成一个值，如求和、求最值、求平均值都是归约操作。</p>
<h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><p>Collectors类专门为汇总提供了一个工厂方法：<code>Collectors.summingInt</code>。<br>它可接受一 个把对象映射为求和所需int的函数，并返回一个收集器；该收集器在传递给普通的 <code>collect</code> 方法后即执行我们需要的汇总操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 计数</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Collectors.counting</span></span><br><span class="line"><span class="comment"> * count</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 2. 最值</span></span><br><span class="line"><span class="comment"> * Collectors.maxBy</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 3. 求和</span></span><br><span class="line"><span class="comment"> * Collectors.summingInt</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 4. 求平均值</span></span><br><span class="line"><span class="comment"> * Collectors.averagingInt</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 5. 连接字符串</span></span><br><span class="line"><span class="comment"> * Collectors.joining</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 6. 一般归约</span></span><br><span class="line"><span class="comment"> * Collectors.reducing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Project&gt; projects = Project.buildData();</span><br><span class="line">        Double collect = projects.stream()</span><br><span class="line">                .collect(averagingInt(Project::getStars));</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        System.out.println(Stream.of(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Java8&quot;</span>)</span><br><span class="line">                .collect(joining(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        Integer collect1 = projects.stream()</span><br><span class="line">                .collect(reducing(<span class="number">0</span>, Project::getStars, (x, y) -&gt; x + y));</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">        Optional&lt;Integer&gt; collect2 = projects.stream()</span><br><span class="line">                .map(Project::getStars)</span><br><span class="line">                .collect(reducing((x, y) -&gt; x + y));</span><br><span class="line">        System.out.println(collect2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>数据分组是一种更自然的分割数据操作，分组就是将流中的元素按照指定类别进行划分，类似于SQL语句中的 <code>GROUPBY</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据作者名进行分组</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Collectors.groupingBy</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 然后根据编程语言类型做前后端分组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Project&gt; projects = Project.buildData();</span><br><span class="line">        Map&lt;String, List&lt;Project&gt;&gt; collect = projects.stream()</span><br><span class="line">                .collect(groupingBy(Project::getAuthor));</span><br><span class="line">        System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h4><p>多级分组可以支持在完成一次分组后，分别对每个小组再进行分组。<br>使用具有两个参数的 <code>groupingBy</code> 重载方法即可实现多级分组。</p>
<ul>
<li>第一个参数：一级分组的条件</li>
<li>第二个参数：一个新的 <code>groupingBy</code> 函数，该函数包含二级分组的条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据作者名进行分组</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Collectors.groupingBy</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 然后根据编程语言类型做前后端分组</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Example3 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, Long&gt;&gt; collect1 &#x3D; projects.stream()</span><br><span class="line">                .collect(groupingBy(Project::getAuthor,</span><br><span class="line">                        groupingBy(p -&gt; &#123;</span><br><span class="line">                            if (&quot;java&quot;.equalsIgnoreCase(p.getLanguage()) ||</span><br><span class="line">                                    &quot;python&quot;.equalsIgnoreCase(p.getLanguage())) &#123;</span><br><span class="line">                                return &quot;后端&quot;;</span><br><span class="line">                            &#125;</span><br><span class="line">                            return &quot;前端&quot;;</span><br><span class="line">                        &#125;, counting())</span><br><span class="line">                ));</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转换类型"><a href="#转换类型" class="headerlink" title="转换类型"></a>转换类型</h4><p>有一些收集器可以生成其他集合。比如前面已经见过的 <code>toList</code>，生成了 <code>java.util.List</code> 类的实例。<br>还有 <code>toSet</code> 和 <code>toCollection</code>，分别生成 <code>Set</code> 和 <code>Collection</code> 类的实例。<br>到目前为止， 我已经讲了很多流上的链式操作，但总有一些时候，需要最终生成一个集合——比如：</p>
<ul>
<li>已有代码是为集合编写的，因此需要将流转换成集合传入；</li>
<li>在集合上进行一系列链式操作后，最终希望生成一个值；</li>
<li>写单元测试时，需要对某个具体的集合做断言。</li>
</ul>
<p>使用 <code>toCollection</code>，用定制的集合收集元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.collect(toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>
<p>还可以利用收集器让流生成一个值。 <code>maxBy</code> 和 <code>minBy</code> 允许用户按某种特定的顺序生成一个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将结果收集到 Map 中</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Collectors.toMap</span></span><br><span class="line"><span class="comment"> * Function.identity()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Project&gt; projects = Project.buildData();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; collect = projects.stream()</span><br><span class="line">                .collect(toMap(Project::getName, Project::getStars));</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Project&gt; collect1 = projects.stream()</span><br><span class="line">                .collect(toMap(Project::getName, Function.identity()));</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换类型</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Collectors.toCollection</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Collectors.collectingAndThen</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Collectors.maxBy</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Collectors.minBy</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 按照作者名称筛选出每组star最高的项目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Project&gt; projects = Project.buildData();</span><br><span class="line"></span><br><span class="line">        Collection&lt;Project&gt; collect = projects.stream()</span><br><span class="line">                .collect(toCollection(CopyOnWriteArrayList::<span class="keyword">new</span>));</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Project&gt; collect1 = projects.stream()</span><br><span class="line">                .collect(groupingBy(Project::getAuthor, collectingAndThen(</span><br><span class="line">                        maxBy(Comparator.comparingInt(Project::getStars)),</span><br><span class="line">                        Optional::get</span><br><span class="line">                )));</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h4><p>分区是分组的特殊情况：由一个断言（返回一个布尔值的函数）作为分类函数，它称分区函数。<br>分区函数返回一个布尔值，这意味着得到的分组 <code>Map</code> 的键类型是 <code>Boolean</code>，于是它最多可以分为两组: true是一组，false是一组。</p>
<p>分区的好处在于保留了分区函数返回true或false的两套流元素列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据分区</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Collectors.partitioningBy</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 根据前后端将项目分为两组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBackEnd</span><span class="params">(Project project)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;java&quot;</span>.equalsIgnoreCase(project.getLanguage()) || <span class="string">&quot;python&quot;</span>.equalsIgnoreCase(project.getLanguage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Project&gt; projects = Project.buildData();</span><br><span class="line"></span><br><span class="line">        Map&lt;Boolean, List&lt;Project&gt;&gt; collect = projects.stream()</span><br><span class="line">                .collect(partitioningBy(Example4::isBackEnd));</span><br><span class="line">        System.out.println(collect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h4><p>并行流就是一个把内容分成多个数据块，并用不不同的线程分别处理每个数据块的流。最后合并每个数据块的计算结果。</p>
<p>将一个顺序执行的流转变成一个并发的流只要调用 <code>parallel()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelSum</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>, i -&gt; i +<span class="number">1</span>).limit(n).parallel().reduce(<span class="number">0L</span>,Long::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个并发流转成顺序的流只要调用 <code>sequential()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.parallel().filter(...).sequential().map(...).parallel().reduce();</span><br></pre></td></tr></table></figure>
<p>这两个方法可以多次调用，只有最后一个调用决定这个流是顺序的还是并发的。</p>
<p>并发流使用的默认线程数等于你机器的处理器核心数。</p>
<p>通过这个方法可以修改这个值，这是全局属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;</span>, <span class="string">&quot;12&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>并非使用多线程并行流处理数据的性能一定高于单线程顺序流的性能，因为性能受到多种因素的影响。<br>如何高效使用并发流的一些建议：</p>
<ol>
<li>如果不确定， 就自己测试。</li>
<li>尽量使用基本类型的流 IntStream, LongStream, DoubleStream</li>
<li>有些操作使用并发流的性能会比顺序流的性能更差，比如limit，findFirst，依赖元素顺序的操作在并发流中是极其消耗性能的。findAny的性能就会好很多，应为不依赖顺序。</li>
<li>考虑流中计算的性能(Q)和操作的性能(N)的对比, Q表示单个处理所需的时间，N表示需要处理的数量，如果Q的值越大, 使用并发流的性能就会越高。</li>
<li>数据量不大时使用并发流，性能得不到提升。</li>
<li>考虑数据结构：并发流需要对数据进行分解，不同的数据结构被分解的性能时不一样的。</li>
</ol>
<p><strong>流的数据源和可分解性</strong></p>
<table>
<thead>
<tr>
<th align="center">源</th>
<th align="left">可分解性</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ArrayList</code></td>
<td align="left">非常好</td>
</tr>
<tr>
<td align="center"><code>LinkedList</code></td>
<td align="left">差</td>
</tr>
<tr>
<td align="center"><code>IntStream.range</code></td>
<td align="left">非常好</td>
</tr>
<tr>
<td align="center"><code>Stream.iterate</code></td>
<td align="left">差</td>
</tr>
<tr>
<td align="center"><code>HashSet</code></td>
<td align="left">好</td>
</tr>
<tr>
<td align="center"><code>TreeSet</code></td>
<td align="left">好</td>
</tr>
</tbody></table>
<p><strong>流的特性以及中间操作对流的修改都会对数据对分解性能造成影响。 比如固定大小的流在任务分解的时候就可以平均分配，但是如果有filter操作，那么流就不能预先知道在这个操作后还会剩余多少元素。</strong></p>
<p><strong>考虑终端操作的性能：如果终端操作在合并并发流的计算结果时的性能消耗太大，那么使用并发流提升的性能就会得不偿失。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuhenzhidu/">无恨之都</a></p>
</li>
<li><p>[2] <a target="_blank" rel="noopener" href="https://github.com/biezhi/learn-java8">biezhi</a></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howie Lu">
      <meta itemprop="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="英雄迟暮">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">Java8新特性之二：方法引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-20 09:14:08 / 修改时间：10:00:12" itemprop="dateCreated datePublished" datetime="2021-01-20T09:14:08+08:00">2021-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java8新特性之二：方法引用"><a href="#Java8新特性之二：方法引用" class="headerlink" title="Java8新特性之二：方法引用"></a>Java8新特性之二：方法引用</h2><p>​        上一节介绍了Java8新特性中的Lambda表达式，本小节继续讲解Java8的新特性之二：方法引用。方法引用其实也离不开Lambda表达式。</p>
<h3 id="1、方法引用的使用场景"><a href="#1、方法引用的使用场景" class="headerlink" title="1、方法引用的使用场景"></a>1、方法引用的使用场景</h3><p>　　我们用Lambda表达式来实现匿名方法。但有些情况下，我们用Lambda表达式仅仅是调用一些已经存在的方法，除了调用动作外，没有其他任何多余的动作，在这种情况下，我们倾向于通过方法名来调用它，而Lambda表达式可以帮助我们实现这一要求，它使得Lambda在调用那些已经拥有方法名的方法的代码更简洁、更容易理解。方法引用可以理解为Lambda表达式的另外一种表现形式。</p>
<h3 id="2、方法引用的分类"><a href="#2、方法引用的分类" class="headerlink" title="2、方法引用的分类"></a>2、方法引用的分类</h3><table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
<th>对应的Lambda表达式</th>
</tr>
</thead>
<tbody><tr>
<td>静态方法引用</td>
<td>类名::staticMethod</td>
<td>(args) -&gt; 类名.staticMethod(args)</td>
</tr>
<tr>
<td>实例方法引用</td>
<td>inst::instMethod</td>
<td>(args) -&gt; inst.instMethod(args)</td>
</tr>
<tr>
<td>对象方法引用</td>
<td>类名::instMethod</td>
<td>(inst,args) -&gt; 类名.instMethod(args)</td>
</tr>
<tr>
<td>构建方法引用</td>
<td>类名::new</td>
<td>(args) -&gt; new 类名(args)</td>
</tr>
</tbody></table>
<h3 id="3、方法引用举例"><a href="#3、方法引用举例" class="headerlink" title="3、方法引用举例"></a>3、方法引用举例</h3><h3 id="3-1-静态方法引用"><a href="#3-1-静态方法引用" class="headerlink" title="3.1 静态方法引用"></a>3.1 静态方法引用</h3><p>　　有一个Person类,如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareByAge</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.age.compareTo(b.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　现假设，一个部门有30人，把他们存放在一个数组中，并按年龄排序，通常我们可以自己写一个比较器，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person[] rosterAsArray = <span class="keyword">new</span> Person[<span class="number">30</span>];</span><br><span class="line"><span class="comment">// 添加数组元素省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.getBirthday().compareTo(b.getBirthday());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrays.sort(rosterAsArray, <span class="keyword">new</span> PersonAgeComparator());</span><br></pre></td></tr></table></figure>
<p>　　Arrays.sort的声明为：public static <T> void sort(T[] a, Comparator&lt;? super T&gt; c)，比较器参数Comparator为一个函数式接口，利用上一节Lambda表达式所学知识，可以改写为以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person[] rosterAsArray = <span class="keyword">new</span> Person[<span class="number">30</span>];</span><br><span class="line"> <span class="comment">// 添加数组元素省略</span></span><br><span class="line"> </span><br><span class="line"> Arrays.sort(rosterAsArray, (a,b) -&gt; a.getAge().compareTo(b.getAge()));</span><br></pre></td></tr></table></figure>
<p>　　然而，你会发现，Perdon类中已经有了一个静态方法的比较器：compareByAge，因此，我们改用Person类已经提供的比较器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person[] rosterAsArray = <span class="keyword">new</span> Person[<span class="number">30</span>];</span><br><span class="line"> <span class="comment">// 添加数组元素省略</span></span><br><span class="line"> </span><br><span class="line">Arrays.sort(rosterAsArray, (a,b) -&gt; Person.compareByAge(a,b));</span><br></pre></td></tr></table></figure>
<p>　　以上代码，因为Lambda表达式调用了一个已经存在的静态方法，根据我们第2节表格中的语法，上面的代码可以最终改写成静态方法引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person[] rosterAsArray = <span class="keyword">new</span> Person[<span class="number">30</span>];</span><br><span class="line"> <span class="comment">// 添加数组元素省略</span></span><br><span class="line"> </span><br><span class="line">Arrays.sort(rosterAsArray, Person::compareByAge);</span><br></pre></td></tr></table></figure>
<p>　　下面这个例子更简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">82</span>,<span class="number">22</span>,<span class="number">34</span>,<span class="number">50</span>,<span class="number">9</span>);</span><br><span class="line">        list.sort(Integer::compare);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        对一个Integer列表进行排序，因为Integer中已经存在静态的比较方法compare()，因此可以直接用静态方法引用的方式来调用 ，运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[9, 22, 34, 50, 82]</span><br></pre></td></tr></table></figure>
<h3 id="3-2-实例方法引用"><a href="#3-2-实例方法引用" class="headerlink" title="3.2 实例方法引用"></a>3.2 实例方法引用</h3><p>　　实例方法引用，顾名思义就是调用已经存在的实例的方法，与静态方法引用不同的是类要先实例化，静态方法引用类无需实例化，直接用类名去调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstanceReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TestInstanceReference test = <span class="keyword">new</span> TestInstanceReference();</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;欧阳峰&quot;</span>,<span class="number">32</span>);</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; user.getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda表达式输出结果：&quot;</span> + supplier.get());</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String&gt; supplier2 = user::getName;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例方法引用输出结果：&quot;</span> + supplier2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lambda表达式输出结果：欧阳峰</span><br><span class="line">实例方法引用输出结果：欧阳峰</span><br></pre></td></tr></table></figure>
<h3 id="3-3-对象方法引用"><a href="#3-3-对象方法引用" class="headerlink" title="3.3 对象方法引用"></a>3.3 对象方法引用</h3><p>　　若Lambda参数列表中的第一个参数是实例方法的参数调用者，而第二个参数是实例方法的参数时，可以使用对象方法引用。</p>
<p>String的equals()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   BiPredicate&lt;String,String&gt; bp = (x, y) -&gt; x.equals(y);</span><br><span class="line">   BiPredicate&lt;String,String&gt; bp1 = String::equals;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> test = bp1.test(<span class="string">&quot;xy&quot;</span>, <span class="string">&quot;xx&quot;</span>);</span><br><span class="line">   System.out.println(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　BiPredicate的test()方法接受两个参数，x和y，具体实现为x.equals(y)，满足Lambda参数列表中的第一个参数是实例方法的参数调用者，而第二个参数是实例方法的参数，因此可以使用对象方法引用。</p>
<h3 id="3-4-构造方法引用"><a href="#3-4-构造方法引用" class="headerlink" title="3.4 构造方法引用"></a>3.4 构造方法引用</h3><p>　　注意：需要调用的构造器的参数列表要与函数式接口中抽象方法的参数列表保持一致。</p>
<p>　　如：要获取一个空的User列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;List&lt;User&gt;&gt; userSupplier &#x3D; () -&gt; new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;User&gt; user &#x3D; userSupplier.get();</span><br><span class="line"></span><br><span class="line">Supplier&lt;List&lt;User&gt;&gt; userSupplier2 &#x3D; ArrayList&lt;User&gt;::new;    &#x2F;&#x2F; 构造方法引用写法</span><br><span class="line">List&lt;User&gt; user2 &#x3D; userSupplier.get();</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuhenzhidu/">无恨之都</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/19/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%80%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howie Lu">
      <meta itemprop="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="英雄迟暮">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/19/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%80%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">Java8新特性之一：Lambda表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-19 17:01:23 / 修改时间：17:26:26" itemprop="dateCreated datePublished" datetime="2021-01-19T17:01:23+08:00">2021-01-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java8新特性之一：Lambda表达式"><a href="#Java8新特性之一：Lambda表达式" class="headerlink" title="Java8新特性之一：Lambda表达式"></a>Java8新特性之一：Lambda表达式</h2><p>​        Java8是自java5之后最重大的一次更新，它给JAVA语言带来了很多新的特性（包括编译器、类库、工具类、JVM等），其中最重要的升级是它给我们带来了Lambda表达式和Stream API。</p>
<h3 id="1、什么是Lambda表达式？"><a href="#1、什么是Lambda表达式？" class="headerlink" title="1、什么是Lambda表达式？"></a>1、什么是Lambda表达式？</h3><p>​        Lambda是一个匿名函数，可以理解为是一段可以传递的代码，可以将代码像传递参数、传递数据一样进行传输。使用Lambda表达式，可以写出更加紧凑、更加简洁、更加灵活的代码。</p>
<h3 id="2、使用Lambda的限制条件"><a href="#2、使用Lambda的限制条件" class="headerlink" title="2、使用Lambda的限制条件"></a>2、使用Lambda的限制条件</h3><p>​        Lambda并不是任何地方都可以使用，Lambda表达式需要“函数式接口”的支持。</p>
<h3 id="3、什么是函数式接口？"><a href="#3、什么是函数式接口？" class="headerlink" title="3、什么是函数式接口？"></a>3、什么是函数式接口？</h3><p>​        接口中只有一个抽象方法的接口，称为函数式接口，可以用@FunctionalInterface修饰一下，这里需要注意的是：未使用 @FunctionalInterfaces注解的接口未必就不是函数式接口，一个接口是不是函数式接口的条件只有一条，即接口中只有一个抽象方法的接口（Object类中的方法不算）。而使用@FunctionalInterface注解修饰了的接口就一定是函数式接口，添加@FunctionalInterface注解可以帮助我们检查是否是函数式接口。</p>
<p>JDK中常见的函数式接口有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下接口中虽然有两个方法，但因hashCode()是Object类中的方法，因此该接口也是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FuncInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;  <span class="comment">// Object类中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、Lambda表达式示例"><a href="#4、Lambda表达式示例" class="headerlink" title="4、Lambda表达式示例"></a>4、Lambda表达式示例</h3><p><strong>需求一：开启一个线程，在线程中打印出”Hello World”</strong></p>
<p>​        未使用Lambda表达式时的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;<span class="number">14</span> &#125;</span><br></pre></td></tr></table></figure>
<p>​        使用Lambda时的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>　<strong>需求二：模拟一个计算器，使其可以进行简单的加、减、乘操作</strong></p>
<p>　　（1）、计算器操作函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">operation</span><span class="params">(T t1,T t2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　（2）具体操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">operator</span><span class="params">(Integer v1,Integer v2,Calculator&lt;Integer&gt; calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculator.operation(v1,v2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">add</span><span class="params">(Integer v1,Integer v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operator(v1,v2,(x,y) -&gt; x + y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">subtr</span><span class="params">(Integer v1,Integer v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operator(v1,v2,(x,y) -&gt; x - y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">multi</span><span class="params">(Integer v1,Integer v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operator(v1,v2,(x,y) -&gt; x * y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CalculatorTest calculatorTest = <span class="keyword">new</span> CalculatorTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加法</span></span><br><span class="line">        Integer add = calculatorTest.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减法</span></span><br><span class="line">        Integer sub = calculatorTest.subtr(<span class="number">100</span>,<span class="number">82</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乘法</span></span><br><span class="line">        Integer multi = calculatorTest.multi(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(add);</span><br><span class="line">        System.out.println(sub);</span><br><span class="line">        System.out.println(multi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>​        从需求一中，我们可以看出，使用Lambda比使用匿名内部类代码更加简洁，同时，也可以理解为什么Lambda必须需要函数式接口的支持。我们假设Runnable中有两个方法，那么，“() -&gt; System.out.println(Thread.currentThread().getName())”应该去找哪个方法去实现？</p>
<p>　　从需求二的例子中，我们可以更加理解“一段可以传递的代码”这句话的含义。对数据的操作方法定义在Calculator接口中，而加、减、乘的具体实现代码在各自的方法中，并将这些实现作为参数传递给CalculatorTest类的operator()方法，最终返回操作结果。</p>
</blockquote>
<h3 id="5、Lambda表达式的语法"><a href="#5、Lambda表达式的语法" class="headerlink" title="5、Lambda表达式的语法"></a>5、Lambda表达式的语法</h3><p><strong>5.1 Lambda表达式的语法结构</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表，对应的是接口中对应的抽象方法的参数列表) -&gt; &#123;对抽象方法的实现&#125;</span><br></pre></td></tr></table></figure>
<p>　Lambda表达式语法分在3个部分：</p>
<ol>
<li>左边的参数列表，对应的是函数式接口中抽象方法的参数列表；</li>
<li>中间的符号:-&gt;,为固定写法; </li>
<li>右边大括号内对函数接口抽象方法的实现。</li>
</ol>
<p>　　Lambda表达式的在具体场景下可以有简略写法。</p>
<p><strong>5.2 语法格式一：无参数，无返回值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = () -&gt; &#123;System.out.println(<span class="string">&quot;Hello World&quot;</span>);&#125; </span><br><span class="line">Runnable runnable = () -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);  <span class="comment">// 简写形式</span></span><br></pre></td></tr></table></figure>
<p>​        此时，如果右边的代码简单，只有一行代码时，{}可以省略。</p>
<p><strong>5.2 语法格式二：有一个参数，无返回值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Consumer&lt;String&gt; msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        print((str) -&gt; System.out.println(msg));</span><br><span class="line">        print(str -&gt; System.out.println(msg));  <span class="comment">// 简写</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        此时，左边的()可以省略。</p>
<p><strong>5.3 语法格式三：Lambda体内只有一条语句，且有返回值，return可省略</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">subtr</span><span class="params">(Integer v1,Integer v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operator(v1,v2,(x,y) -&gt; x - y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.4 语法格式四：有两个以上参数，且Lambda体中有多条语句</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">add</span><span class="params">(Integer v1,Integer v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operator(v1,v2,(x,y) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进行加法运算&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.5 语法格式五：Lambda表达式的数据类型可以省略不写</strong></p>
<p>​        JVM编译器通过上下文可以推断出数据类型，但要注意的是，当多个参数时，要么都写，要么都不写，不能有的写，有的不写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">subtr</span><span class="params">(Integer v1,Integer v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operator(v1,v2,(Integer x,y) -&gt; x - y);   <span class="comment">// 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">subtr</span><span class="params">(Integer v1,Integer v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operator(v1,v2,(x,y) -&gt; x - y);    <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="6、Java8四大内置核心函数式接口"><a href="#6、Java8四大内置核心函数式接口" class="headerlink" title="6、Java8四大内置核心函数式接口"></a>6、Java8四大内置核心函数式接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;T&gt; : 消费型接口（无返回值，有去无回）</span><br><span class="line">         void accept(T t);</span><br><span class="line"> Supplier&lt;T&gt; : 供给型接口</span><br><span class="line">         T get();</span><br><span class="line">         </span><br><span class="line"> Function&lt;T,R&gt; : 函数型接口</span><br><span class="line">        R apply(T t);</span><br><span class="line">        </span><br><span class="line"> Predicate&lt;T&gt; : 断言型接口</span><br><span class="line">        boolean test(T t);</span><br><span class="line">        </span><br><span class="line">四大核心接口的--&gt;扩展子接口</span><br></pre></td></tr></table></figure>
<p>​        以上四大核心内置接口是我们日常开发中经常要用到的，同时，它们还有一些变种，如：</p>
<p>​        BiConsumer，Consumer的增强版，接受两个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiConsumer</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        BiFunction类似，Function的增强版，接受两个参数，返回一个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface BiFunction&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    R apply(T t, U u);</span><br><span class="line"></span><br><span class="line">    default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        return (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        其他的类似，这些函数式接口都在java.util.function包下，读者可去这个包下去查询。</p>
<p>　　示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印user信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(User user,Consumer&lt;User&gt; userConsumer)</span> </span>&#123;</span><br><span class="line">        userConsumer.accept(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Supplier&lt;User&gt; userSupplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换一个user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">transformUser</span><span class="params">(User user,Function&lt;User,User&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验User是否合法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUser</span><span class="params">(User user, Predicate&lt;User&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> predicate.test(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        User userObj = <span class="keyword">new</span> User();</span><br><span class="line">        userObj.setUsername(<span class="string">&quot;西门吹雪&quot;</span>);</span><br><span class="line">        userObj.setAge(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试Consumer</span></span><br><span class="line">        InnerInterface mainInst = <span class="keyword">new</span> InnerInterface();</span><br><span class="line">        mainInst.print(userObj,user -&gt; System.out.println(user));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试Supplier</span></span><br><span class="line">        <span class="keyword">final</span> User user1 = mainInst.getUser(() -&gt; &#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setUsername(<span class="string">&quot;叶孤城&quot;</span>);</span><br><span class="line">            user.setAge(<span class="number">22</span>);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将西门吹雪的年龄改为25</span></span><br><span class="line">        <span class="keyword">final</span> User user2 = mainInst.transformUser(userObj, (user -&gt; &#123;</span><br><span class="line">            user.setAge(<span class="number">25</span>);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断User是否是西门吹雪</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> checkUser = mainInst.checkUser(userObj, (user -&gt; user.getUsername().equals(<span class="string">&quot;西门吹雪&quot;</span>)));</span><br><span class="line">        System.out.println(checkUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuhenzhidu/">无恨之都</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/19/Java%E7%9A%84%E5%8F%91%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howie Lu">
      <meta itemprop="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="英雄迟暮">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/19/Java%E7%9A%84%E5%8F%91%E5%B1%95/" class="post-title-link" itemprop="url">Java的发展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-19 09:28:57 / 修改时间：16:56:23" itemprop="dateCreated datePublished" datetime="2021-01-19T09:28:57+08:00">2021-01-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-的发展"><a href="#Java-的发展" class="headerlink" title="Java 的发展"></a>Java 的发展</h1><h2 id="JDK-5"><a href="#JDK-5" class="headerlink" title="JDK 5"></a>JDK 5</h2><p><strong>自动装箱与拆箱</strong></p>
<p>JDK1.5为每一个基本数据类型定义了一个封装类。使java中的基本数据类型也有自己的对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int --&gt;Integer</span><br><span class="line">double --&gt; Double</span><br><span class="line">long --&gt; Long</span><br><span class="line">char --&gt; Character</span><br><span class="line"><span class="built_in">float</span> --&gt; Float</span><br><span class="line">boolean --&gt; Boolean</span><br><span class="line">short --&gt; Short</span><br><span class="line">byte -- &gt; Byte</span><br></pre></td></tr></table></figure>
<ul>
<li>自动装包：将基本类型转换成为对象，例如：<code>int --&gt; Integer</code></li>
<li>自动拆包：将对象转换成为基本数据类型，例如：<code>Integer --&gt; int</code></li>
</ul>
<p>对于 JDK1.5 之前集合总不能存放基本数据类型的问题，现在也能够解决。</p>
<p><strong>枚举</strong></p>
<p>枚举是 JDK1.5 推出的一个比较重要的特性。其关键字为 <code>enum</code><br>例如：定义代表交通灯的枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">MyEnum</span></span>&#123;</span><br><span class="line">    RED,GREEN,YELLOW</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态导入</strong></p>
<ul>
<li><p>优点：使用静态导入可以使被导入类的所有静态变量和静态方法在当前类直接可见，使用这些静态成员无需再给出他们的类名。</p>
</li>
<li><p>缺点：过度使用会降低代码的可读性</p>
</li>
</ul>
<p><strong>变长参数</strong></p>
<p>在JDK1.5以前，当我们要为一个方法传递多个类型相同的参数时，<br>我们有两种方法解决</p>
<ol>
<li>直接传递一个数组过去</li>
<li>有多少个参数就传递多少个参数。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printColor</span><span class="params">(String red,String green,String yellow)</span></span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printColor</span><span class="params">(String[] colors)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样编写方法参数虽然能够实现我们想要的效果，但是，这样是不是有点麻烦呢？<br>再者，如果参数个数不确定，我们怎么办呢？Java JDK1.5为我们提供的可变参数就能够完美的解决这个问题.</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printColor</span><span class="params">(String... colors)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数的类型相同，那么可以使用 <code>类型+三个点</code> ，后面跟一个参数名称的形式。<br>这样的好处就是，只要参数类型相同，无论传递几个参数都没有限制<br>注意：可变参数必须是参数列表的最后一项（该特性对对象和基本数据类型都适用）</p>
<p><strong>泛型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给集合指定存入类型，上面这个集合在存入数据的时候必须存入String类型的数据，否则编译器会报错</span></span><br><span class="line">List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。<br>可见泛型的提出是为了编写重用性更好的代码。<br>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>比如常见的集合类 <code>LinkedList</code>，其实现的接口名后有个特殊的部分 <code>&lt;&gt;</code>，而且它的成员的类型 Link 也包含一个 <code>&lt;&gt;</code>，这个符号的就是类型参数，<br>它使得在运行中，创建一个 LinkedList 时可以传入不同的类型，比如 <code>new LinkedList</code>，这样它的成员存放的类型也是 <code>String</code>。</p>
<p><strong>For-Each循环</strong></p>
<p>例如上面这个集合我们可以通过for-each遍历，这样更加简单清晰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String s : strs)&#123; </span><br><span class="line">     System.out.println(s); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：使用for-each遍历集合时，要遍历的集合必须实现了Iterator接口</p>
</blockquote>
<p><strong>线程并发库</strong></p>
<p>线程并发库是 Java1.5 提出的关于多线程处理的高级功能，所在包：<code>java.util.concurrent</code> 包括</p>
<ol>
<li>线程互斥工具类：Lock，ReadWriteLock</li>
<li>线程通信：Condition</li>
<li>线程池：ExecutorService</li>
<li>同步队列：ArrayBlockingQueue</li>
<li>同步集合：ConcurrentHashMap，CopyOnWriteArrayList</li>
<li>线程同步工具：Semaphore</li>
</ol>
<h2 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK 6"></a>JDK 6</h2><p><strong>Desktop类和SystemTray类</strong></p>
<p>前者可以用来打开系统默认浏览器浏览指定的URL，打开系统默认邮件客户端给指定的邮箱发邮件，<br>用默认应用程序打开或编辑文件(比如，用记事本打开以 txt 为后缀名的文件)，<br>用系统默认的打印机打印文档；后者可以用来在系统托盘区创建一个托盘程序。</p>
<p><strong>使用Compiler API</strong></p>
<p>现在我们可以用JDK1.6 的Compiler API(JSR 199)去动态编译Java源文件，<br>Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。</p>
<p>这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，<br>是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件。<br>当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，<br>这种方式需要我们产生另一个进程去做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；<br>Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译，而且是跨平台的。</p>
<p><strong>轻量级Http Server API</strong></p>
<p>JDK1.6 提供了一个简单的 Http Server API，据此我们可以构建自己的嵌入式 Http Server，<br>它支持Http和Https协议，提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的 Http Server API来实现，<br>程序员必须自己实现 HttpHandler 接口，HttpServer 会调用 <code>HttpHandler</code> 实现类的回调方法来处理客户端请求，<br>在这里，我们把一个 Http 请求和它的响应称为一个交换，包装成 <code>HttpExchange</code> 类，<code>HttpServer</code> 负责将 <code>HttpExchange</code> 传给 <code>HttpHandler</code> 实现类的回调方法。</p>
<p><strong>用Console开发控制台程序</strong></p>
<p>JDK1.6 中提供了 <code>java.io.Console</code> 类专用来访问基于字符的控制台设备。<br>你的程序如果要与 Windows 下的 cmd 或者 Linux 下的 Terminal 交互，就可以用 <code>Console</code> 类代劳。<br>但我们不总是能得到可用的 Console，一个JVM是否有可用的 Console 依赖于底层平台和 JVM 如何被调用。<br>如果JVM是在交互式命令行(比如 Windows 的 cmd)中启动的，并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的 Console 实例。</p>
<p><strong>对脚本语言的支持</strong></p>
<p>如：ruby，groovy，javascript。</p>
<h2 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h2><p><strong>数字变量对下滑线的支持</strong></p>
<p>JDK1.7可以在数值类型的变量里添加下滑线，但是有几个地方是不能添加的</p>
<ol>
<li>数字的开头和结尾 </li>
<li>小数点前后 </li>
<li>F或者L前</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1234_5678_9</span>; </span><br><span class="line"><span class="keyword">float</span> num2 = <span class="number">222_33F</span>; </span><br><span class="line"><span class="keyword">long</span> num3 = <span class="number">123_000_111L</span>;</span><br></pre></td></tr></table></figure>
<p><strong>switch对String的支持</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String status = <span class="string">&quot;orderState&quot;</span>;     </span><br><span class="line"><span class="keyword">switch</span> (status) &#123;   </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ordercancel&quot;</span>:   </span><br><span class="line">        System.out.println(<span class="string">&quot;订单取消&quot;</span>);   </span><br><span class="line">        <span class="keyword">break</span>;   </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;orderSuccess&quot;</span>:   </span><br><span class="line">        System.out.println(<span class="string">&quot;预订成功&quot;</span>);   </span><br><span class="line">        <span class="keyword">break</span>;   </span><br><span class="line">    <span class="keyword">default</span>:   </span><br><span class="line">        System.out.println(<span class="string">&quot;状态未知&quot;</span>);   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>try-with-resource</strong></p>
<ul>
<li><code>try-with-resources</code> 是一个定义了一个或多个资源的 try 声明，这个资源是指程序处理完它之后需要关闭它的对象。</li>
<li><code>try-with-resources</code> 确保每一个资源在处理完成后都会被关闭。</li>
</ul>
<p>可以使用try-with-resources的资源有： 任何实现了 <code>java.lang.AutoCloseable</code> 接口 <code>java.io.Closeable</code> 接口的对象。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readFirstLineFromFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;   </span><br><span class="line">        <span class="keyword">return</span> br.readLine();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>在 java 7 以及以后的版本里，<code>BufferedReader</code> 实现了 <code>java.lang.AutoCloseable</code> 接口。<br>由于 <code>BufferedReader</code> 定义在 <code>try-with-resources</code> 声明里，无论 <code>try</code> 语句正常还是异常的结束，<br>它都会自动的关掉。而在 java7 以前，你需要使用 <code>finally</code> 块来关掉这个对象。</p>
<p><strong>捕获多种异常并用改进后的类型检查来重新抛出异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">try</span> &#123;   </span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;&quot;</span>));   </span><br><span class="line">        Connection con = <span class="keyword">null</span>;   </span><br><span class="line">        Statement stmt = con.createStatement();   </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | SQLException e) &#123;   </span><br><span class="line">        <span class="comment">//捕获多个异常，e就是final类型的   </span></span><br><span class="line">        e.printStackTrace();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>优点：用一个 <code>catch</code> 处理多个异常，比用多个 <code>catch</code> 每个处理一个异常生成的字节码要更小更高效。</p>
<p><strong>创建泛型时类型推断</strong></p>
<p>只要编译器可以从上下文中推断出类型参数，你就可以用一对空着的尖括号 <code>&lt;&gt;</code> 来代替泛型参数。<br>这对括号私下被称为菱形(diamond)。 在Java SE 7之前，你声明泛型对象时要这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>而在Java SE7以后，你可以这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>因为编译器可以从前面(List)推断出推断出类型参数，所以后面的 <code>ArrayList</code> 之后可以不用写泛型参数了，只用一对空着的尖括号就行。<br>当然，你必须带着菱形 <code>&lt;&gt;</code>，否则会有警告的。<br>Java SE7 只支持有限的类型推断：只有构造器的参数化类型在上下文中被显著的声明了，你才可以使用类型推断，否则不行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();l</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>); </span><br><span class="line"><span class="comment">//这个不行 </span></span><br><span class="line">list.addAll(<span class="keyword">new</span> ArrayList&lt;&gt;()); </span><br><span class="line"><span class="comment">// 这个可以 </span></span><br><span class="line">List&lt;? extends String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">list.addAll(list2);</span><br></pre></td></tr></table></figure>


<h2 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h2><p><strong>Lambda表达式和函数式接口</strong></p>
<p>Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，<br>或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成。</p>
<p>Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了函数接口这个概念。函数接口指的是只有一个函数的接口，这样的接口可以隐式转换为Lambda表达式。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解@FunctionalInterface（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义</p>
<p><strong>接口的默认方法和静态方法</strong></p>
<p>Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。</p>
<p>默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。<br>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写<br>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。<br>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考官方文档。</p>
<p><strong>更好的类型推断</strong></p>
<p>Java 8 编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。</p>
<p>参数 <code>Value.defaultValue()</code> 的类型由编译器推导得出，不需要显式指明。在Java 7中这段代码会有编译错误，除非使用 <code>Value.&lt;String&gt;defaultValue()</code>。</p>
<p><strong>Optional</strong></p>
<p>Java应用中最常见的bug就是空值异常。在Java 8之前，Google Guava引入了 <code>Optionals</code> 类来解决 <code>NullPointerException</code>，<br>从而避免源码被各种 <code>null</code> 检查污染，以便开发者写出更加整洁的代码。Java 8也将Optional加入了官方库。<br><code>Optional</code> 仅仅是一个容易存放T类型的值或者null。它提供了一些有用的接口来避免显式的null检查，可以参考Java 8官方文档了解更多细节。</p>
<p>如果Optional实例持有一个非空值，则 <code>isPresent()</code> 方法返回true，否则返回false；<code>orElseGet()</code> 方法，Optional实例持有null，<br>则可以接受一个lambda表达式生成的默认值；map()方法可以将现有的 <code>Optional</code> 实例的值转换成新的值；orElse()方法与orElseGet()方法类似，<br>但是在持有null的时候返回传入的默认值。</p>
<p><strong>Streams</strong></p>
<p>新增的Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。<br>这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。</p>
<p>Task 类有一个分数（或伪复杂度）的概念，另外还有两种状态：OPEN 或者 CLOSED。现在假设有一个task集合，<br>首先看一个问题：在这个task集合中一共有多少个OPEN状态的点？在Java 8之前，要解决这个问题，则需要使用foreach循环遍历task集合；<br>但是在Java 8中可以利用steams解决：包括一系列元素的列表，并且支持顺序和并行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Collection&lt;Task&gt; tasks = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Task(Status.OPEN, <span class="number">5</span>),</span><br><span class="line">        <span class="keyword">new</span> Task(Status.OPEN, <span class="number">13</span>),</span><br><span class="line">        <span class="keyword">new</span> Task(Status.CLOSED, <span class="number">8</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate total points of all active tasks using sum()</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> totalPointsOfOpenTasks = tasks</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(task -&gt; task.getStatus() == Status.OPEN)</span><br><span class="line">        .mapToInt(Task::getPoints)</span><br><span class="line">        .sum();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Total points: &quot;</span> + totalPointsOfOpenTasks);</span><br></pre></td></tr></table></figure>
<p>这里有很多知识点值得说。首先，tasks集合被转换成steam表示；其次，在steam上的filter操作会过滤掉所有CLOSED的task；<br>第三，mapToInt操作基于每个task实例的Task::getPoints方法将task流转换成Integer集合；最后，通过sum方法计算总和，得出最后的结果。</p>
<p><strong>新的日期时间 API</strong></p>
<p>Java 8引入了新的Date-Time API(JSR 310)来改进时间、日期的处理。时间和日期的管理一直是最令Java开发者痛苦的问题。<br>java.util.Date 和后来的 java.util.Calendar 一直没有解决这个问题（甚至令开发者更加迷茫）。</p>
<p>因为上面这些原因，诞生了第三方库Joda-Time，可以替代Java的时间管理API。<br>Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。<br>新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。<br>新设计的API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训），如果某个实例需要修改，则返回一个新的对象。</p>
<p>第二，关注下LocalDate和LocalTime类。LocalDate仅仅包含ISO-8601日历系统中的日期部分；LocalTime则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用Clock对象构建得到。<br>LocalDateTime类包含了LocalDate和LocalTime的信息，但是不包含ISO-8601日历系统中的时区信息。这里有一些关于LocalDate和LocalTime的例子：<br>如果你需要特定时区的data/time信息，则可以使用ZoneDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。</p>
<p><strong>Nashorn JavaScript引擎</strong></p>
<p>Java 8提供了新的Nashorn JavaScript引擎，使得我们可以在JVM上开发和运行JS应用。<br>Nashorn JavaScript引擎是javax.script.ScriptEngine的另一个实现版本，这类Script引擎遵循相同的规则，允许Java和JavaScript交互使用，例子代码如下：</p>
<p><strong>Base64</strong></p>
<p>对 Base64 编码的支持已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码，例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String text = <span class="string">&quot;Lets Learn Java 8!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String encoded = Base64</span><br><span class="line">        .getEncoder()</span><br><span class="line">        .encodeToString(text.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">System.out.println(encoded);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String decoded = <span class="keyword">new</span> String(</span><br><span class="line">        Base64.getDecoder().decode(encoded),</span><br><span class="line">        StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(decoded);</span><br></pre></td></tr></table></figure>
<p>新的Base64API也支持URL和MINE的编码解码。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://github.com/biezhi/learn-java8">biezhi</a></li>
<li>[2] <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">JAVA8 API</a></li>
</ul>
<h1 id="无恨之都"><a href="#无恨之都" class="headerlink" title="无恨之都"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuhenzhidu/">无恨之都</a></h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/14/%E4%BF%A1%E6%89%98%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howie Lu">
      <meta itemprop="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="英雄迟暮">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/14/%E4%BF%A1%E6%89%98%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">信托业务知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-14 10:17:48" itemprop="dateCreated datePublished" datetime="2021-01-14T10:17:48+08:00">2021-01-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/12/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howie Lu">
      <meta itemprop="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="英雄迟暮">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/12/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/" class="post-title-link" itemprop="url">Java语法（内部类）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-12 11:25:14" itemprop="dateCreated datePublished" datetime="2021-01-12T11:25:14+08:00">2021-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-13 11:13:27" itemprop="dateModified" datetime="2021-01-13T11:13:27+08:00">2021-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>我们所说的类都对应于一个独立的Java源文件，但一个类还可以放在另一个类的内部，称之为内部类，相对而言，包含它的类称之为外部类。</p>
<p>为什么要放到别的类内部呢？</p>
<p>一般而言，内部类与包含它的外部类有比较密切的关系，而与其他类关系不大，定义在类内部，可以实现对外部完全隐藏，可以有更好的封装性，代码实现上也往往更为简洁。</p>
<p>不过，内部类只是Java编译器的概念，对于Java虚拟机而言，它是不知道内部类这回事的, 每个内部类最后都会被编译为一个独立的类，生成一个独立的字节码文件。</p>
</blockquote>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><blockquote>
<p>在Java中，根据定义的位置和方式不同，主要有四种内部类：</p>
<ul>
<li>静态内部类</li>
<li>成员内部类</li>
<li>方法内部类</li>
<li>匿名内部类</li>
</ul>
<p>方法内部类是在一个方法内定义和使用的，匿名内部类使用范围更小，它们都不能在外部使用，成员内部类和静态内部类可以被外部使用，不过它们都可以被声明为private，这样，外部就使用不了了。</p>
</blockquote>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p><strong>语法</strong></p>
<p>静态内部类与静态变量和静态方法定义的位置一样，也带有static关键字，只是它定义的是类，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> shared = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner &quot;</span> + shared);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StaticInner si = <span class="keyword">new</span> StaticInner();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部类为Outer，静态内部类为StaticInner，带有static修饰符。</p>
<p>语法上，静态内部类除了位置放在别的类内部外，它与一个独立的类差别不大，可以有静态变量、静态方法、成员方法、成员变量、构造方法等。它可以访问外部类的静态变量和方法，如innerMethod直接访问shared变量，但不可以访问实例变量和方法。在类内部，可以直接使用内部静态类，如test()方法所示。</p>
<p>静态内部类可以被外部使用，只是需要通过”外部类.静态内部类”的方式使用，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner si = <span class="keyword">new</span> Outer.StaticInner();</span><br><span class="line">si.innerMethod();</span><br></pre></td></tr></table></figure>


<p><strong>实现原理</strong></p>
<p>以上代码实际上会生成两个类，一个是Outer，另一个是Outer$StaticInner，它们的代码大概如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> shared = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Outer$StaticInner si = <span class="keyword">new</span> Outer$StaticInner();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">0</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> shared;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$<span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inner &quot;</span> + Outer.access$<span class="number">0</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类访问了外部类的一个私有静态变量shared，而我们知道私有变量是不能被类外部访问的，Java的解决方法是，自动为Outer生成了一个非私有访问方法access$0，它返回这个私有静态变量shared。</p>
<p><strong>使用场景</strong></p>
<blockquote>
<p>静态内部类使用场景是很多的，如果它与外部类关系密切，且不依赖于外部类实例，则可以考虑定义为静态内部类。</p>
<p>比如说，一个类内部，如果既要计算最大值，也要计算最小值，可以在一次遍历中将最大值和最小值都计算出来，但怎么返回呢？可以定义一个类Pair，包括最大值和最小值，但Pair这个名字太普遍，而且它主要是类内部使用的，就可以定义为一个静态内部类。</p>
<p>我们也可以看一些在Java API中使用静态内部类的例子：</p>
<ul>
<li>Integer类内部有一个私有静态内部类IntegerCache，用于支持整数的自动装箱。</li>
<li>表示链表的LinkedList类内部有一个私有静态内部类Node，表示链表中的每个节点。</li>
<li>Character类内部有一个public静态内部类UnicodeBlock，用于表示一个Unicode block。</li>
</ul>
</blockquote>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>成员内部类没有static修饰符，少了一个static修饰符，但含义却有很大不同，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;outer a &quot;</span> +a);</span><br><span class="line">            Outer.<span class="keyword">this</span>.action();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Inner就是成员内部类，与静态内部类不同，除了静态变量和方法，成员内部类还可以直接访问外部类的实例变量和方法.</p>
<p>innerMethod直接访问外部类私有实例变量a。成员内部类还可以通过”外部类.this.xxx”的方式引用外部类的实例变量和方法，如Outer.this.action()，这种写法一般在重名的情况下使用，没有重名的话，”外部类.this.”是多余的。</p>
</blockquote>
<blockquote>
<p>在外部类内，使用成员内部类与静态内部类是一样的，直接使用即可，如test()方法所示。</p>
<p>与静态内部类不同，成员内部类中不可以定义静态变量和方法 (final变量例外，它等同于常量）</p>
<p>与静态内部类不同，成员内部类对象总是与一个外部类对象相连的，在外部使用时，它不能直接通过new Outer.Inner()的方式创建对象，而是要先将创建一个Outer类对象，代码如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">inner.innerMethod();</span><br></pre></td></tr></table></figure>


<p><strong>实现原理</strong></p>
<p>以上代码也会生成两个类，一个是Outer，另一个是Outer$Inner，它们的代码大概如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Outer$Inner inner = <span class="keyword">new</span> Outer$Inner(<span class="keyword">this</span>);</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">0</span>(Outer outer) &#123;</span><br><span class="line">        <span class="keyword">return</span> outer.a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> access$<span class="number">1</span>(Outer outer) &#123;</span><br><span class="line">        outer.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$<span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Outer outer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Outer$Inner(Outer outer)&#123;</span><br><span class="line">        ths.outer = outer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer a &quot;</span></span><br><span class="line">                + Outer.access$<span class="number">0</span>(outer));</span><br><span class="line">        Outer.access$<span class="number">1</span>(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Outer$Inner类有个实例变量outer指向外部类的对象，它在构造方法中被初始化，Outer在新建Outer$Inner对象时传递当前对象给它，由于内部类访问了外部类的私有变量和方法，外部类Outer生成了两个非私有静态方法，access$0用于访问变量a，access$1用于访问方法action。</p>
</blockquote>
<p><strong>使用场景</strong></p>
<blockquote>
<p>如果内部类与外部类关系密切，且操作或依赖外部类实例变量和方法，则可以考虑定义为成员内部类。</p>
<p>外部类的一些方法的返回值可能是某个接口，为了返回这个接口，外部类方法可能使用内部类实现这个接口，这个内部类可以被设为private，对外完全隐藏。</p>
<p>比如说，在Java API 类LinkedList中，它的两个方法listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表遍历，listIterator和descendingIterator内部分别使用了成员内部类ListItr和DescendingIterator，这两个内部类都实现了接口Iterator。关于LinkedList，后续文章我们还会介绍。</p>
</blockquote>
<h4 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h4><p><strong>语法</strong></p>
<p>内部类还可以定义在一个方法体中，示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> param)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;outer a &quot;</span> +a);</span><br><span class="line">                System.out.println(<span class="string">&quot;param &quot;</span> +param);</span><br><span class="line">                System.out.println(<span class="string">&quot;local var &quot;</span> +str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类Inner定义在外部类方法test中，方法内部类只能在定义的方法内被使用。</p>
<p>如果方法是实例方法，则除了静态变量和方法，内部类还可以直接访问外部类的实例变量和方法，如innerMethod直接访问了外部私有实例变量a。</p>
<p>如果方法是静态方法，则方法内部类只能访问外部类的静态变量和方法。</p>
<p>方法内部类还可以直接访问方法的参数和方法中的局部变量，不过，这些变量必须被声明为final，如innerMethod直接访问了方法参数param和局部变量str。</p>
</blockquote>
<p><strong>实现原理</strong></p>
<p>系统生成的两个类代码大概如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        OuterInner inner = <span class="keyword">new</span> OuterInner(<span class="keyword">this</span>, param);</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">0</span>(Outer outer)&#123;</span><br><span class="line">        <span class="keyword">return</span> outer.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterInner</span> </span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    <span class="keyword">int</span> param;</span><br><span class="line">    </span><br><span class="line">    OuterInner(Outer outer, <span class="keyword">int</span> param)&#123;</span><br><span class="line">        <span class="keyword">this</span>.outer = outer;</span><br><span class="line">        <span class="keyword">this</span>.param = param;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer a &quot;</span></span><br><span class="line">                + Outer.access$<span class="number">0</span>(<span class="keyword">this</span>.outer));</span><br><span class="line">        System.out.println(<span class="string">&quot;param &quot;</span> + param);</span><br><span class="line">        System.out.println(<span class="string">&quot;local var &quot;</span> + <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>使用场景</strong></p>
<blockquote>
<p>方法内部类都可以用成员内部类代替，至于方法参数，也可以作为参数传递给成员内部类。不过，如果类只在某个方法内被使用，使用方法内部类，可以实现更好的封装。</p>
</blockquote>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p><strong>语法</strong></p>
<p>匿名内部类没有名字，在创建对象的同时定义类，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类(参数列表) &#123;</span><br><span class="line">   <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 父接口() &#123;</span><br><span class="line">   &#x2F;&#x2F;匿名内部类实现部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看个具体的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>)&#123;                </span><br><span class="line">                                               </span><br><span class="line">            <span class="meta">@Override</span>                              </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">()</span> </span>&#123;             </span><br><span class="line">                <span class="keyword">return</span> distance(<span class="keyword">new</span> Point(x,y));     </span><br><span class="line">            &#125;                                      </span><br><span class="line">        &#125;;                                       </span><br><span class="line">                                                 </span><br><span class="line">        System.out.println(p.distance());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>匿名内部类只能被使用一次，用来创建一个对象。它没有名字，没有构造方法，但可以根据参数列表，调用对应的父类构造方法。</strong>它可以定义实例变量和方法，可以有初始化代码块，初始化代码块可以起到构造方法的作用，只是构造方法可以有多个，而初始化代码块只能有一份。</p>
<p><strong>因为没有构造方法，它自己无法接受参数，如果必须要参数，则应该使用其他内部类。</strong></p>
<p><strong>与方法内部类一样，匿名内部类也可以访问外部类的所有变量和方法，可以访问方法中的final参数和局部变量</strong></p>
</blockquote>
<p><strong>实现原理</strong></p>
<p>每个匿名内部类也都被生成为了一个独立的类，只是类的名字以外部类加数字编号，没有有意义的名字。上例中，产生了两个类Outer和Outer$1，代码大概如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Outer$<span class="number">1</span>(<span class="keyword">this</span>,<span class="number">2</span>,<span class="number">3</span>,x,y);                                            </span><br><span class="line">        System.out.println(p.distance());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$1 <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">    <span class="keyword">int</span> y2;</span><br><span class="line">    Outer outer;</span><br><span class="line">    </span><br><span class="line">    Outer$<span class="number">1</span>(Outer outer, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)&#123;</span><br><span class="line">        <span class="keyword">super</span>(x1,y1);</span><br><span class="line">        <span class="keyword">this</span>.outer = outer;</span><br><span class="line">        <span class="keyword">this</span>.x2 = x2;</span><br><span class="line">        <span class="keyword">this</span>.y2 = y2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>                              </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">()</span> </span>&#123;             </span><br><span class="line">        <span class="keyword">return</span> distance(<span class="keyword">new</span> Point(<span class="keyword">this</span>.x2,y2));     </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>使用场景</strong></p>
<blockquote>
<p> 匿名内部类能做的，方法内部类都能做。但如果对象只会创建一次，且不需要构造方法来接受参数，则可以使用匿名内部类，代码书写上更为简洁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortIgnoreCase</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">    Arrays.sort(strs, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/swiftma/tag/">老马编程</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/08/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howie Lu">
      <meta itemprop="description" content="当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="英雄迟暮">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/08/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/" class="post-title-link" itemprop="url">Java语法（泛型）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-08 09:28:57" itemprop="dateCreated datePublished" datetime="2021-01-08T09:28:57+08:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-12 11:23:37" itemprop="dateModified" datetime="2021-01-12T11:23:37+08:00">2021-01-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>“泛型”字面意思就是广泛的类型，类、接口和方法代码可以应用于非常广泛的类型，代码与它们能够操作的数据类型不再绑定在一起，同一套代码，可以用于多种数据类型，这样，不仅可以复用代码，降低耦合，同时，还可以提高代码的可读性和安全性。</p>
<p>泛型是计算机程序中一种重要的思维方式，它将数据结构和算法与数据类型相分离，使得同一套数据结构和算法，能够应用于各种数据类型，而且还可以保证类型安全，提高可读性</p>
</blockquote>
<p><strong>注意（在集合中使用泛型）:</strong></p>
<ol>
<li>集合接口和集合类在jdk1.5时都修改为带泛型的结构</li>
<li>在实例化集合类时,可以指明具体的泛型类型</li>
<li>泛型的类型必须是类，不能是基本类型。基本类型需要拿包装类替换</li>
<li>使用时没有指定泛型，默认为java.lang.Object类型</li>
</ol>
<blockquote>
<p>一个简单的泛型例子</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    T first;</span><br><span class="line">    T second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a><strong>基本原理</strong></h4><blockquote>
<p>Java有Java编译器和Java虚拟机，编译器将Java源代码转换为.class文件，虚拟机加载并运行.class文件。对于泛型类，Java编译器会将泛型代码转换为普通的非泛型代码，将类型参数T擦除，替换为Object，插入必要的强制类型转换。Java虚拟机实际执行的时候，它是不知道泛型这回事的，它只知道普通的类及代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object first;</span><br><span class="line">    Object second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="泛型分类"><a href="#泛型分类" class="headerlink" title="泛型分类"></a>泛型分类</h4><ul>
<li>泛型类（类的内部结构可以使用泛型）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    T first;</span><br><span class="line">    T second;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//多参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">U</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    U first;</span><br><span class="line">    V second;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>泛型方法(泛型方法和泛型类没有关系)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T[] arr, T elm)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(elm))&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U,V&gt; <span class="function">Pair&lt;U,V&gt; <span class="title">makePair</span><span class="params">(U first, V second)</span></span>&#123;</span><br><span class="line">    Pair&lt;U,V&gt; pair = <span class="keyword">new</span> Pair&lt;&gt;(first, second);</span><br><span class="line">    <span class="keyword">return</span> pair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>泛型接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="泛型通配符-具体请参考下方参考资料"><a href="#泛型通配符-具体请参考下方参考资料" class="headerlink" title="泛型通配符(具体请参考下方参考资料)"></a>泛型通配符(具体请参考下方参考资料)</h4><ul>
<li><p><T extends E>和&lt;? extends E&gt;到底有什么关系？</p>
<ul>
<li><p><T extends E>用于定义类型参数，它声明了一个类型参数T，可放在泛型类定义中类名后面、泛型方法返回值前面。</p>
</li>
<li><? extends E>用于实例化类型参数，它用于实例化泛型变量中的类型参数，只是这个具体类型是未知的，只知道它是E或E的某个子类型。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然它们不一样，但两种写法经常可以达成相同目标，比如，前面例子中，下面两种写法都可以：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T extends E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(DynamicArray&lt;T&gt; c)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(DynamicArray&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
<ul>
<li><p>泛型中的三种通配符形式，&lt;?&gt;、&lt;? extends E&gt;和&lt;? super E&gt;,简单总结来说：</p>
<ul>
<li><?>和<? extends E>用于实现更为灵活的读取，它们可以用类型参数的形式替代，但通配符形式更为简洁。
</li>
<li><? super E>用于实现更为灵活的写入和比较，不能被类型参数形式替代。



</li>
</ul>
</li>
</ul>
<ul>
<li><p>在使用泛型类、方法和接口时，有一些值得注意的地方，比如：</p>
<ul>
<li>基本类型不能用于实例化类型参数</li>
<li>运行时类型信息不适用于泛型</li>
<li>类型擦除可能会引发一些冲突</li>
</ul>
</li>
</ul>
<ul>
<li><p>在定义泛型类、方法和接口时，也有一些需要注意的地方，比如：</p>
<ul>
<li><p>不能通过类型参数创建对象</p>
</li>
<li><p>泛型类类型参数不能用于静态变量和方法</p>
</li>
<li><p>了解多个类型限定的语法  以&amp;分割    类型擦除时会用第一个上界替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends Base &amp; Comparable &amp; Serializable</span><br></pre></td></tr></table></figure></li>
<li><p>不能创建泛型数组</p>
</li>
</ul>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/swiftma/tag/">老马编程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Howie Lu</p>
  <div class="site-description" itemprop="description">当你的才华还撑不起你的野心的时候，你就应该静下心来学习。当你的能力还驾驭不了你的目标的时候，你就应该沉下心来历练。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/pizzaup" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pizzaup" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Howie Lu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
